---
title: 13. UART
type: docs
weight: 13
BookToC: false
---

# 13. Universal asynchronous transceiver UART

## 13.1 Introduction to UART

CH559 chip provides two full-duplex asynchronous serial ports: UART0 and UART1. UART0 is a standard MCS51 serial port. Its data reception and transmission are realized through SBUF access to physically separate transmit / receive registers. The data written to SBUF is loaded into the transmit register, and the read operation to SBUF corresponds to the receive buffer register.

UART1 is an enhanced asynchronous serial port with the following features:

1. Compatible with 16C550 asynchronous serial port and enhanced.
2. Support 5, 6, 7 or 8 data bits and 1 or 2 stop bits.
3. support odd, even, no parity, blank 0, flag 1 and other verification methods.
4. Programmable communication baud rate, supporting 115200bps and communication baud rate up to 3Mbps.
5. .Built-in independent transmit and receive buffers and 8-byte FIFO FIFO buffer, support 4 FIFO trigger levels.
6. Support MODEM modem signals CTS, DSR, RI, DCD, DTR, RTS, can be externally converted to RS232 level.
7. Support hardware flow control signals CTS and RTS automatic handshake and automatic transmission rate control, compatible with TL16C550C.
8. Support for serial frame error detection and Break line interval detection.
9. Built-in SIR infrared codec, support IrDA infrared communication with baud rate of 2400bps to 115200bps.
10. Supports full-duplex and half-duplex serial communication, and provides a status pin for switching RS485.
11. Built-in half-duplex differential transceiver, directly supports simple long-distance multi-machine communication similar to RS485 bus.
12. Support to preset the address when this machine is used as a slave, used to automatically match the data packets on the bus when multi-machine communication.

## 13.2 UART Register

<div>
    <p align="center">Table 13.2.1 List of UART related registers</p>
</div>

<table>
    <tr>
        <th>Name</th><th>Address</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>SBUF</td><td> 99h</td><td> UART0 data register</td><td> xxh</td></tr>
    <tr><td>SCON</td><td> 98h</td><td> UART0 Control Register</td><td> 00h</td></tr>
    <tr><td>SER1_DLL</td><td> 9Ah</td><td> UART1 baud rate divisor latch low byte</td><td> xxh</td></tr>
    <tr><td>SER1_RBR</td><td> 9Ah</td><td> UART1 data receive buffer register (read only)</td><td> xxh</td></tr>
    <tr><td>SER1_THR</td><td> 9Ah</td><td> UART1 data transmission holding register (write only)</td><td> xxh</td></tr>
    <tr><td>SER1_FIFO</td><td> 9Ah</td><td> UART1 data FIFO read and write register</td><td> xxh</td></tr>
    <tr><td>SER1_DIV </td><td>97h </td><td>UART1 prescaler divisor register</td><td> xxh</td></tr>
    <tr><td>SER1_ADDR</td><td> 97h</td><td> UART1 bus address preset register </td><td>FFh</td></tr>
    <tr><td>SER1_MSR</td><td> 96h</td><td> Modem MODEM status register (read only)</td><td> F0h</td></tr>
    <tr><td>SER1_LSR</td><td> 95h</td><td> UART1 line status register (read only)</td><td> 60h</td></tr>
    <tr><td>SER1_MCR</td><td> 94h</td><td> Modem MODEM control register </td><td>00h</td></tr>
    <tr><td>SER1_LCR</td><td> 93h</td><td> UART1 line control register </td><td>00h</td></tr>
    <tr><td>SER1_IIR</td><td> 92h</td><td> UART1 interrupt identification register (read only) </td><td>01h</td></tr>
    <tr><td>SER1_FCR</td><td> 92h</td><td> FIFO control register (write only) </td><td>00h</td></tr>
    <tr><td>SER1_DLM</td><td> 91h</td><td> UART1 baud rate divisor latch high byte </td><td>80h</td></tr>
    <tr><td>SER1_IER</td><td> 91h</td><td> UART1 interrupt enable register </td><td>00h</td></tr>
    
</table>

### 13.2.1 UART0 Register Description

### UART0 control register (SCON):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>7</td><td>SM0</td><td>RW</td><td>UART0 working mode selection bit 0, this bit is 0 selects 8-bit data asynchronous communication; this bit is 1 selects 9-bit data asynchronous communication</td><td>0</td></tr>
    <tr><td>6</td><td>SM1</td><td>RW</td><td>UART0 working mode selection bit 1, this bit is 0 to set the fixed baud rate. This bit is 1 to set the variable baud rate, generated by timer T1 or T2</td><td>0</td></tr>
    <tr><td>5</td><td>SM2</td><td>RW</td><td><p>UART0 multi-machine communication control bit:</p><p>When receiving data in modes 2 and 3, when SM2 = 1, if RB8 is 0, then RI is not set to 1, reception is invalid. If RB8 is 1, then RI is set to 1, reception is valid. When SM2 = 0</p><p>When RB8 is 0 or 1, RI is set when receiving data, and the reception is valid. In mode 1, if SM2 = 1, then the reception is valid only when a valid stop bit is received. In mode 0, SM2 Bit must be set to 0</p></td><td>0</td></tr>
    <tr><td>4</td><td>REN</td><td>RW</td><td>UART0 enable reception control bit, this bit is 0 to disable reception; this bit is 1 to enable reception</td><td>0</td></tr>
    <tr><td>3</td><td>TB8</td><td>RW</td><td>The 9th bit of the transmitted data. In modes 2 and 3, TB8 is used to write the 9th bit of the transmitted data, which can be a parity bit.In multi-machine communication, it is used to indicate whether the host sends an address byte Data byte, TB8 = 0 is data, TB8 = 1 is address</td><td>0</td></tr>
    <tr><td>2</td><td>RB8</td><td>RW</td><td>The 9th bit of the received data, in modes 2 and 3, RB8 is used to store the 9th bit of received data. In mode 1, if SM2 = 0, then RB8 is used to store the received stop bit. In mode 0 Without using RB8</td><td>0</td></tr>
    <tr><td>1</td><td>TI</td><td>RW</td><td>Send interrupt flag bit, which is set by hardware after a data byte is transmitted and needs to be cleared by software</td><td>0</td></tr>
    <tr><td>0</td><td>RI</td><td>RW</td><td>Receive interrupt flag bit, which is set by hardware after a data byte is received and needs to be cleared by software</td><td>0</td></tr>
    
</table>

<div>
    <p align="center">Table 13.2.1.1 UART0 working mode selection</p>
</div>

<table>
    <tr>
        <th>SM0</th><th>SM1</th><th>Description</th>
    </tr>
    <tr><td>0</td><td> 0</td><td> Mode 0, shift register mode, fixed baud rate is Fsys / 12</td></tr>
    <tr><td>0</td><td> 1</td><td> Mode 1, 8-bit asynchronous communication mode, variable baud rate, generated by timer T1 or T2</td></tr>
    <tr><td>1</td><td> 0</td><td> mode 2, 9-bit asynchronous communication mode, the baud rate is Fsys / 128 (SMOD = 0) or Fsys / 32 (SMOD = 1)</td></tr>
    <tr><td>1</td><td> 1</td><td> Mode 3, 9-bit asynchronous communication, variable baud rate, generated by timer T1 or T2</td></tr>
    
</table>

In modes 1 and 3, when RCLK = 0 and TCLK = 0, the UART0 baud rate is generated by timer T1. T1 should be set to mode 2 auto-reload 8-bit timer mode, bT1_CT and bT1_GATE must both be 0, divided into the following types of clock situations.

<div>
    <p align="center">Table 13.2.1.2 Calculation formula of UART0 baud rate generated by T1</p>
</div>

<table>
    <tr>
        <th>bTMR_CLK</th><th>bT1_CLK</th><th>SMOD</th><th>Description</th>
    </tr>
    <tr><td>1</td><td> 1</td><td> 0</td><td> TH1 = 256-Fsys/32/ baud rate</td></tr>
    <tr><td>1</td><td> 1</td><td> 1</td><td> TH1 = 256-Fsys/16/ baud rate</td></tr>
    <tr><td>0</td><td> 1</td><td> 0</td><td> TH1 = 256-Fsys/4/32/ baud rate</td></tr>
    <tr><td>0</td><td> 1</td><td> 1</td><td> TH1 = 256-Fsys/4/16/ baud rate</td></tr>
    <tr><td>X</td><td> 0</td><td> 0</td><td> TH1 = 256-Fsys/12/32/ baud rate</td></tr>
    <tr><td>X</td><td> 0</td><td> 1</td><td> TH1 = 256-Fsys/12/16/ baud rate</td></tr>
    
</table>

In modes 1 and 3, when RCLK = 1 or TCLK = 1, the baud rate of UART0 is generated by timer T2. T2 should be set to 16-bit automatic re-carrier rate generator mode, C_T2 and CP_RL2 must both be 0, divided into the following types of clock situations.

<div>
    <p align="center">Table 13.2.1.3 Calculation formula of UART0 baud rate generated by T2</p>
</div>

<table>
    <tr>
        <th>bTMR_CLK</th><th>bT2_CLK</th><th>Description</th>
    </tr>
    <tr><td>1</td><td> 1</td><td> RCAP2 = 65536-Fsys/16 / baud rate</td></tr>
    <tr><td>0</td><td> 1</td><td> RCAP2 = 65536-Fsys/2/16 / baud rate</td></tr>
    <tr><td>X</td><td> 0</td><td> RCAP2 = 65536-Fsys/4/16 / baud rate</td></tr>
    
</table>

### UART0 data register (SBUF):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:0]</td><td>SBUF</td><td>RW</td><td>UART0 data register, including sending and receiving two physically separate registers. Writing data to SBUF corresponds to the transmit data register. Reading data from SBUF corresponds to the receive data register</td><td>xxh</td></tr>
    
</table>

### 13.2.2 UART1 Related Registers

UART1 data FIFO read and write register SER1_FIFO, including data receiving buffer register SER1_RBR and data transmission holding register SER1_THR two physically separate registers.

### Data receive buffer register (SER1_RBR), only valid when bLCR_DLAB = 0:

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:0]</td><td>SER1_RBR</td><td>RO</td><td>Serial port receive buffer register. If the bLSR_DATA_RDY bit of SER1_LSR is 1, you can read the received data from this register. If bFCR_FIFO_EN is 1, the data received from the serial port shift register is first stored in the receive FIFO and then passed This register reads</td><td>xxh</td></tr>
    
</table>

### Data transmission holding register (SER1_THR), only valid when bLCR_DLAB = 0:

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:0]</td><td>SER1_THR</td><td>WO</td><td>The serial port transmission holding register, including the transmission FIFO, is used to write the data to be transmitted. If bFCR_FIFO_EN is 1, the written data is first stored in the transmission FIFO and then output one by one through the transmission shift register</td><td>xxh</td></tr>
    
</table>

### Interrupt enable register (SER1_IER), only valid when bLCR_DLAB = 0:

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
    <tr><td>7</td><td> bIER_RESET </td><td>RW</td><td> Serial port software reset control bit. This bit is 1 to reset the serial port. This bit can be automatically cleared without software clear</td><td> 0</td></tr>
    <tr><td>6</td><td> bIER_EN_MODEM_O </td><td>RW</td><td> UART1 Modem signal output enable bit, this bit is 1 to enable MODEM signal RTS / DTR output, this bit is 0 to disable output</td><td> 0</td></tr>
    <tr><td>5</td><td> bIER_PIN_MOD1 </td><td>RW</td><td> UART1 pin mode selection high</td><td> 0</td></tr>
    <tr><td>4</td><td> bIER_PIN_MOD0 </td><td>RW</td><td> UART1 pin mode selection low</td><td> 0</td></tr>
    <tr><td>3</td><td> bIER_MODEM_CHG </td><td>RW</td><td> Modem input status change interrupt enable bit, this bit is 1 to enable the modem input status change interrupt. This bit is 0 to disable</td><td> 0</td></tr>
    <tr><td>2</td><td> bIER_LINE_STAT </td><td>RW</td><td> Receive line status interrupt enable bit, this bit is 1 to enable the receive line status interrupt. This bit is 0 to disable</td><td> 0</td></tr>
    <tr><td>1</td><td> bIER_THR_EMPTY </td><td>RW</td><td> Transmit Holding Register Empty Interrupt Enable Bit. This bit is 1 to enable the transmit holding register empty interrupt. This bit is 0 to disable.</td><td> 0</td></tr>
    <tr><td>0</td><td> bIER_RECV_RDY </td><td>RW</td><td> Received data interrupt enable bit, this bit is 1 to enable generation of receive data completion interrupt and subsequent timeout interrupt of received data, this bit is 0 disable</td><td> 0</td></tr>
    
</table>

The pin mode of UART1 consists of both bIER_PIN_MOD1 and bIER_PIN_MOD0 and bUH1_DISABLE, bXBUS_CS_OE, bXBUS_AL_OE, bALE_CLK_EN are combined to select different configurations.Among them, the last four can be combined into RS485EN:

<div>
    <p align="center">RS485EN = bUH1_DISABLE & ~ ( bXBUS_CS_OE & ~ bXBUS_AL_OE | bALE_CLK_EN )</p>
</div>

<table>
    <tr>
        <th>RS485EN</th><th>bIER_PIN_MOD1</th><th>bIER_PIN_MOD0</th><th>Description</th>
    </tr>
    <tr><td>x</td><td> 0</td><td> 0</td><td> RXD1 uses pin P4.0, TXD1 disables output</td></tr>
    <tr><td>0</td><td> 1</td><td> 0</td><td> RXD1 and TXD1 use pins P2.6 / RXD1 and P2.7 / TXD1 respectively</td></tr>
    <tr><td>0</td><td> 0</td><td> 1</td><td> RXD1 and TXD1 use pins P4.0 / RXD1_ and P4.4 / TXD1_ respectively</td></tr>
    <tr><td>0</td><td> 1</td><td> 1</td><td> RXD1 and TXD1 and TNOW use pins P2.6 and P2.7 and P2.5 respectively</td></tr>
    <tr><td>1</td><td> 1</td><td> 0</td><td> RXD1 and TXD1 share iRS485 differential pins XA and XB</td></tr>
    <tr><td>1</td><td> 0</td><td> 1</td><td> RXD1 and TXD1 use pins XA and XB together, TNOW uses pin P4.4</td></tr>
    <tr><td>1</td><td> 1</td><td> 1</td><td> RXD1 and TXD1 use pins XA and XB together, TNOW uses pin P2.5</td></tr>
    
</table>

The last three configurations in the above table are iRS485 half-duplex communication mode.At this time, RS485EN = 1, RXD1 and TXD1 use iRS485 differential pins XA and XB together. Through the built-in half-duplex differential transceiver, it directly supports simple RS485 Long-distance multi-machine communication of the bus.

In iRS485 half-duplex communication mode, the following parameters need to be set:

1. Set bMCR_HALF in SER1_MCR to 1, half-duplex transceiver mode;
2. Set bUH1_DISABLE in UHUB1_CTRL to 1 to disable the HP / HM pin.


### Interrupt Identification Register (SER1_IIR):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:6]</td><td>MASK_U1_IIR_ID</td><td>R0</td><td>FIFO enable flag, 11 means FIFO is enabled</td><td>00b</td></tr>
    <tr><td>[5:4]</td><td>reserved</td><td>R0</td><td>reserved</td><td>00b</td></tr>
    <tr><td>[3:0]</td><td>MASK_U1_IIR_INT</td><td>R0</td><td>UART1 interrupt status flag</td><td>0001b</td></tr>
    <tr><td>0</td><td>bIIR_NO_INT</td><td>R0</td><td>UART1 is interrupt flag, it is 1 without interrupt. 0 is interrupt</td><td>1</td></tr>
    
</table>

The interrupt status of UART1 is composed of 4 bits, bIIR_INT_FLAG3, bIIR_INT_FLAG2, bIIR_INT_FLAG1, and bIIR_INT_FLAG0. MASK_U1_IIR_INT is used as the serial port interrupt flag of UART1. The specific interrupts are shown in the following table.

<table>
    <tr>
        <th>Name</th><th>Address</th><th>Interrupt type</th><th>Interrupt source</th><th>Clear interrupt method</th>
    </tr>
    <tr><td>U1_INT_SLV_ADDR</td><td>0Eh</td><td>Bus address match</td><td>Received 1 data is the serial bus address, and the address matches the preset value or broadcast address</td><td>Read SER1_IIR or disable multi-machine mode</td></tr>
    <tr><td>U1_INT_LINE_STAT</td><td>06h</td><td>Receive line status</td><td>bLSR_OVER_ERR or bLSR_PAR_ERR or bLSR_FRAME_ERR or bLSR_BREAK_ERR</td><td>Read SER1_LSR</td></tr>
    <tr><td>U1_INT_RECV_RDY</td><td>04h</td><td>Receive data available</td><td>The number of received bytes reaches the trigger point of the FIFO</td><td>Read SER1_RBR</td></tr>
    <tr><td>U1_INT_RECV_TOUT</td><td>0Ch</td><td>Receive data timeout</td><td>Data has been received, but the next data has not been received for more than 4 data bytes</td><td>Read SER1_RBR</td></tr>
    <tr><td>U1_INT_THR_EMPTY</td><td>02h</td><td>SER1_THR register is empty</td><td>The transmit holding register is empty, and bIER_THR_EMPTY changes from 0 to 1 to re-enable the interrupt</td><td>Read SER1_IIR or write SER1_THR</td></tr>
    <tr><td>U1_INT_MODEM_CHG</td><td>00h</td><td>MODEM input change</td><td>△ CTS or △ DSR or △ RI or △ DCD</td><td>Read SER1_MSR</td></tr>
    <tr><td>U1_INT_NO_INTER</td><td>01h</td><td>No interruption</td><td>Without interruption</td><td></td></tr>

    
</table>

### FIFO control register (SER1_FCR):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>7</td><td>bFCR_FIFO_TRIG1</td><td>W0</td><td>Receive FIFO interrupt and hardware flow control trigger point set high</td><td>0</td></tr>
    <tr><td>6</td><td>bFCR_FIFO_TRIG0</td><td>W0</td><td>Receive FIFO interrupt and hardware flow control trigger point set low</td><td>0</td></tr>
    <tr><td>[5:3]</td><td>reserved</td><td>R0</td><td>reserved</td><td>000b</td></tr>
    <tr><td>2</td><td>bFCR_T_FIFO_CLR</td><td>W0</td><td>Send FIFO data clear enable bit, this bit is 1 to clear the data in the transmit FIFO (excluding the data being transmitted). This bit can be automatically cleared without software clearing</td><td>0</td></tr>
    <tr><td>1</td><td>bFCR_R_FIFO_CLR</td><td>W0</td><td>Receive FIFO data clear enable bit, this bit is 1 to clear the data in the receive FIFO (excluding the data being received). This bit can be cleared automatically without software clearing</td><td>0</td></tr>
    <tr><td>0</td><td>bFCR_FIFO_EN</td><td>W0</td><td>FIFO enable bit, this bit is 1 to enable FIFO; this bit is 0 to disable FIFO. After disabling FIFO, it is 16C450 compatible mode, which is equivalent to FIFO having only one byte depth.It is recommended to enable FIFO</td><td>0</td></tr>
    
</table>

bFCR_FIFO_TRIG1 and bFCR_FIFO_TRIG0 form MASK_U1_FIFO_TRIG, which is used to set the interrupt point of the receive FIFO and the trigger point of hardware flow control: 11 corresponds to 7 bytes, that is, the reception of full 7 bytes generates an interrupt that is available for receiving data. When = 1, the level of the RTS pin is automatically disabled. 10 corresponds to 4 bytes. 01 corresponds to 2 bytes. 00 corresponds to 1 byte.

### Line Control Register (SER1_LCR):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>7</td><td>bLCR_DLAB</td><td>RW</td><td>Baud rate divisor latch access enable bit. This bit is 0 to enable access to the registers SER1_RBR, SER1_THR, SER1_IER, SER1_ADR. This bit is 1 to enable access to the registers SER1_DLL, SER1_DLM, SER1_DIV</td><td>0</td></tr>
    <tr><td>6</td><td>bLCR_BREAK_EN</td><td>RW</td><td>Force BREAK line interval enable bit, this bit is 0, no BREAK output is generated. This bit is 1, force BREAK output</td><td>0</td></tr>
    <tr><td>5</td><td>bLCR_PAR_MOD1</td><td>RW</td><td>High parity mode</td><td>0</td></tr>
    <tr><td>4</td><td>bLCR_PAR_MOD0</td><td>RW</td><td>Low parity mode</td><td>0</td></tr>
    <tr><td>3</td><td>bLCR_PAR_EN</td><td>RW</td><td>Parity enable bit. This bit is 0. There is no parity bit. This bit is 1 to allow parity check bits to be generated during transmission and received during reception.</td><td>0</td></tr>
    <tr><td>2</td><td>bLCR_STOP_BIT</td><td>RW</td><td>Stop bit format setting bit, this bit is 0, there is a stop bit; this bit is 1, there are two stop bits</td><td>0</td></tr>
    <tr><td>1</td><td>bLCR_WORD_SZ1</td><td>RW</td><td>Data word length set high</td><td>0</td></tr>
    <tr><td>0</td><td>bLCR_WORD_SZ0</td><td>RW</td><td>Data word length set low</td><td>0</td></tr>
    
</table>

The combination of bLCR_PAR_MOD1 and bLCR_PAR_MOD0 sets the format of the parity bit when bLCR_PAR_EN is 1: 00 for odd parity, 01 for even parity, 10 for flag bit (MARK, set to 1), and 11 for blank bit (SPACE, cleared to 0) ).

The combination of bLCR_WORD_SZ1 and bLCR_WORD_SZ0 sets the word length of a single data without parity: 00 is 5 data bits, 01 is 6 data bits, 10 is 7 data bits, and 11 is 8 data bits.

### MODEM control register (SER1_MCR):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>7</td><td>bMCR_HALF</td><td>RW</td><td>Half-duplex transmit / receive mode enable bit. This bit is 0 to disable the half-duplex transmit / receive mode and support full duplex. The bit is 1 to enter the automatic half-duplex transmit / receive mode. Sending takes priority. Receiving is suspended during transmission. For receiving</td><td>0</td></tr>
    <tr><td>6</td><td>bMCR_TNOW</td><td>RW</td><td>RTS pin function selection bit, this bit is 0 for standard RTS output; this bit is 1 for TNOW output, and the state of output is being transmitted, which can be used to control the half-duplex mode of RS485.</td><td>0</td></tr>
    <tr><td>5</td><td>bMCR_AUTO_FLOW</td><td>RW</td><td>CTS and RTS hardware automatic flow control enable bit, this bit is 0 to disable hardware flow control. This bit is 1 to enable hardware automatic flow control.After hardware flow control is enabled, the serial port will continue to send the next data only when the CTS pin input is active low, otherwise the serial port transmission will be suspended. After hardware flow control is enabled, if bMCR_RTS is 1, then when the receive FIFO is empty, The serial port will automatically activate the low-level RTS pin automatically. When the number of bytes received reaches the trigger point of the FIFO, the serial port will automatically invalidate the RTS pin and be able to activate the RTS pin again when the receive FIFO is empty. After enabling hardware flow control CTSA change in input state does not generate a MODEM state interrupt. By connecting your own CTS pin to the other's RTS pin and sending your own RTS pin to the other's CTS pin, you can implement hardware automatic rate control</td><td>0</td></tr>
    <tr><td>4</td><td>bMCR_LOOP</td><td>RW</td><td>Test mode enable bit for internal loop, this bit is 0 to disable internal loop test. This bit is 1 to enable internal loop test. In the internal loop test mode, all external output pins of the serial port are inactive.TXD1 internally returns to RXD1, RTS internally returns to CTS, DTR internally returns to DSR, OUT1 internally returns to RI, and OUT2 internally returns to DCD.</td><td>0</td></tr>
    <tr><td>3</td><td>bMCR_OUT2</td><td>RW</td><td>Serial port interrupt request output enable bit, this bit is 0 to disable the serial port interrupt request output, this bit is 1 to enable the serial port interrupt request output</td><td>0</td></tr>
    <tr><td>2</td><td>bMCR_OUT1</td><td>RW</td><td>User-defined MODEM control bit, no actual output pin is connected, used for internal loop test, or as a general-purpose data bit</td><td>0</td></tr>
    <tr><td>1</td><td>bMCR_RTS</td><td>RW</td><td>RTS pin output control bit. When this bit is 0, the RTS pin output is invalid (high level). When the bit is 1, the RTS pin output is valid (low level)</td><td>0</td></tr>
    <tr><td>0</td><td>bMCR_DTR</td><td>RW</td><td>DTR pin output control bit. When this bit is 0, the DTR pin output is invalid (high level). When the bit is 1, the DTR pin output is valid (low level)</td><td>0</td></tr>
    
</table>

### Line Status Register (SER1_LSR):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>7</td><td>bLSR_ERR_R_FIFO</td><td>R0</td><td>Error flag of the receive FIFO. This bit is 1 indicating that there is at least one bLSR_PAR_ERR, bLSR_FRAME_ERR, or bLSR_BREAK_ERR error in the receive FIFO.</td><td>0</td></tr>
    <tr><td>6</td><td>bLSR_T_ALL_EMP</td><td>R0</td><td>Transmit related register full empty flag bit, this bit is 1 means the transmit holding register SER1_THR and FIFO and transmit shift register are empty</td><td>1</td></tr>
    <tr><td>5</td><td>bLSR_T_FIFO_EMP</td><td>R0</td><td>This bit is 1 to indicate that the transmit holding registers SER1_THR and FIFO are empty</td><td>1</td></tr>
    <tr><td>4</td><td>bLSR_BREAK_ERR</td><td>R0</td><td>When this bit is 1, it indicates that BREAK line interval status is detected</td><td>0</td></tr>
    <tr><td>3</td><td>bLSR_FRAME_ERR</td><td>R0</td><td>This bit is 1 to indicate that the current data in the receive FIFO is framing, and a valid stop bit is missing</td><td>0</td></tr>
    <tr><td>2</td><td>bLSR_PAR_ERR</td><td>R0</td><td>This bit is 1 to indicate the parity error of the current data in the receive FIFO</td><td>0</td></tr>
    <tr><td>1</td><td>bLSR_OVER_ERR</td><td>R0</td><td>This bit is 1 to indicate the receive FIFO buffer overflow</td><td>0</td></tr>
    <tr><td>0</td><td>bLSR_DATA_RDY</td><td>R0</td><td>This bit is 1 to indicate that there is received data in the receive FIFO. After reading all the data in the FIFO, this bit is automatically cleared to 0</td><td>0</td></tr>
    
</table>

### Modem MODEM status register (SER1_MSR):

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>7</td><td>bMSR_DCD</td><td>R0</td><td>This bit is the bit inversion of the DCD pin. A value of 1 indicates that the DCD pin is active (active low)</td><td>1</td></tr>
    <tr><td>6</td><td>bMSR_RI</td><td>R0</td><td>This bit is the bit inversion of the RI pin. A 1 indicates that the RI pin is active (active low)</td><td>1</td></tr>
    <tr><td>5</td><td>bMSR_DSR</td><td>R0</td><td>This bit is the bit inversion of the DSR pin. A value of 1 indicates that the DSR pin is active (active low)</td><td>1</td></tr>
    <tr><td>4</td><td>bMSR_CTS</td><td>R0</td><td>This bit is the bit inversion of the CTS pin. A 1 indicates that the CTS pin is active (active low)</td><td>1</td></tr>
    <tr><td>3</td><td>bMSR_DCD_CHG</td><td>R0</td><td>This bit is 1 to indicate that the input status of the DCD pin has changed.</td><td>0</td></tr>
    <tr><td>2</td><td>bMSR_RI_CHG</td><td>R0</td><td>This bit is 1 to indicate that the input state of the RI pin has changed</td><td>0</td></tr>
    <tr><td>1</td><td>bMSR_DSR_CHG</td><td>R0</td><td>This bit is 1 to indicate that the input state of the DSR pin has changed</td><td>0</td></tr>
    <tr><td>0</td><td>bMSR_CTS_CHG</td><td>R0</td><td>This bit is 1 to indicate that the CTS pin input state has changed</td><td>0</td></tr>
    
</table>

### UART1 bus address preset register (SER1_ADDR), only valid when bLCR_DLAB = 0:

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:0]</td><td>SER1_ADDR</td><td>RW</td><td>Preset bus address for automatic comparison in multi-machine communication</td><td>FFh</td></tr>
    
</table>

SER1_ADDR presets the address when this machine is used as a slave. It is used to automatically compare the received addresses during multi-machine communication, and to generate an interrupt when the addresses match or when it receives the broadcast address 0FFH, and at the same time allow receiving subsequent data packets. Do not receive any data before the address does not match. After starting to send data or after rewriting the SER1_ADDR register, stop receiving any data until the next time the address matches again or the broadcast address is received.

When SER1_ADDR is 0FFH or bLCR_PAR_EN = 0, the automatic comparison of bus addresses is disabled.

When SER1_ADDR is not 0FFH and bLCR_PAR_EN = 1, the automatic comparison of the bus address is enabled, and the following parameters should be configured: bLCR_WORD_SZ1 and bLCR_WORD_SZ0 are both 1 to select 8 data bits. BLCR_PAR_MOD1 is always 1. For the address byte is MARK In the case where bit 9 of the data byte is 0, bLCR_PAR_MOD0 should be set to 1.For the case where the address byte is SPACE (that is, bit 9 of the data byte is 1), bLCR_PAR_MOD0 should be set to 0, that is, select according to the data byte.


### UART1 baud rate divisor latch (SER1_DLM, SER1_DLL), only valid when bLCR_DLAB = 1:

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:0]</td><td>SER1_DLL</td><td>RW</td><td rowspan="2">SER1_DLL is the low byte and SER1_DLM is the high byte. The two form a 16-bit divisor and are used for a serial baud rate generator composed of a 16-bit counter. These registers can only be read and written when bLCR_DLAB is 1. The divisor = Fsys * 2 / SER1_DIV / 16 / baud rate</td><td>xxh</td></tr>
    <tr><td>[7:0]</td><td>SER1_DLM</td><td>RW</td><td>80h</td></tr>
    
</table>

### UART1 prescaler divisor register (SER1_DIV), only valid when bLCR_DLAB = 1:

<table>
    <tr>
        <th>Bit</th><th>Name</th><th>Access</th><th>Description</th><th>Reset value</th>
    </tr>
    <tr><td>[7:0]</td><td>SER1_DIV</td><td>RW</td><td>It is used to multiply the system main clock Fsys and then pre-divide to generate the internal reference clock of the serial port baud rate generator. This register can only be read and written when bLCR_DLAB is 1</td><td>xxh</td></tr>
    
</table>

## 13.3 UART Application

### UART0 application:

1. Select the baud rate generator of UART0, you can choose from timer T1 or T2, and configure the corresponding counter.
2. Start the timer.
3. Set SM0, SM1, and SM2 of SCON to select the working mode of serial port 0. Set REN to 1 to enable UART0 reception.
4. You can set the serial port interrupt or query the RI and TI interrupt status.
5. Read and write SBUF implements serial data transmission and reception, the allowable baud rate error of the serial port receiving signal is not greater than 2%.

### UART1 application:

1. Set the bit bLCR_DLAB of SER1_LCR to 1, write the UART1 prescaler register SER1_DIV, calculate the baud rate divisor according to the baud rate, the divisor = Fsys / 8 / SER1_DIV / baud rate, and the high n. low bytes of the divisor are written to SER1_DLM And SER1_DLL.
2. Set SER1_LCR, select the appropriate serial data format, data byte, and parity mode.
3. Optional setting SER1_IER, select UART1 interrupt status trigger.
4. If the interrupt mode is used, the bit bMCR_OUT2 of SER1_MCR needs to be set to 1 to enable the interrupt output; otherwise, the interrupt status bit needs to be queried actively.
5. Read and write SER1_FIFO to realize serial data transmission and reception, the allowable baud rate error of the serial port receiving signal is not greater than 2%.

