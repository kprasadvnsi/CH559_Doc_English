'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/1-overview/','title':"1. Overview",'content':"8-bit enhanced USB microcontroller CH559 1. Overview The CH559 chip is an enhanced E8051 core microcontroller compatible with the MCS51 instruction set. Its 79% of instructions are single-byte single-cycle instructions, and the average instruction speed is 8 to 15 times faster than the standard MCS51.\nThe CH559 supports up to 56MHz system clock speed, built-in 64K program memory Flash-ROM and 256-byte internal iRAM and 6K bytes of on-chip xRAM. Some xRAMs support DMA direct memory access.\nThe CH559 has built-in ADC analog-to-digital conversion, four groups of timers and PWM, dual asynchronous serial port, dual SPI, and other functional modules, as well as a built-in dual-port Root-HUB that supports USB-Host host mode and USB-Device device mode.\nThe following is an internal block diagram of the CH559 for reference only.\n"});index.add({'id':1,'href':'/docs/2-features/','title':"2. Features",'content':"8-bit enhanced USB microcontroller CH559 2. Features   Core: Enhanced E8051 core, compatible with MCS51 instruction set, 79% of instructions are single-byte single-cycle instructions, average command speed is 8~15 times faster than standard MCS51, special XRAM data fast copy instruction, double DPTR pointer.\n  ROM: 64KB non-volatile memory Flash-ROM, support 100K erasing, can be used for program storage space; or can be divided into 60KB program storage area and 1KB data storage area and 3KB boot code BootLoader/ISP program area.\n  RAM: 256 bytes internal iRAM, can be used for fast data temporary storage and stack; 6KB on-chip xRAM, can be used for large data temporary storage and DMA direct memory access; support for external expansion of 32KB external SRAM.\n  USB: Embedded USB controller and dual USB transceiver, support USB-Host host mode and USB-Device device mode, support USB 2.0 full speed 12Mbps or low speed 1.5Mbps, USB host mode can manage two simultaneously through dual port Root-HUB USB devices. Supports up to 64 bytes of data packets, built-in FIFO, and support for DMA.\n  Timer: 4 groups of timers, T0/T1/T2 are standard MCS51 timers; T2 is extended to support 2 signal captures; TMR3 has 8 levels of FIFOs, supports DMA, supports signal capture sampling and 16-bit PWM output.\n  PWM: 3 sets of PWM outputs, PWM1/PWM2 are 2 8-bit PWM outputs; TMR3 supports 16-bit PWM outputs.\n  UART: 2 sets of asynchronous serial port, UART0 is standard MCS51 serial port; UART1 is compatible with 16C550, built-in 8-stage FIFO, supports Modem signal, supports RS485 half-duplex mode, supports preset local address for automatic matching in multi-machine communication.\n  SPI: 2 sets of SPI controllers with clock frequency up to half of the system\u0026rsquo;s main frequency Fsys, supporting serial data input and output simplex multiplexing. SPI0 has built-in FIFO and supports Master/Slave master-slave mode; SPI1 only supports host mode.\n  ADC: 8-channel 10-bit or 11-bit A/D analog-to-digital converter with built-in 2-stage FIFO, support for DMA, support for up to 1MSPS sample rate, and support for two-channel automatic wheel test.\n  LED-CTRL: LED screen control card data transmission interface, built-in 4-level FIFO, support DMA, support 1/2/4 data line interface, clock frequency up to half of the system frequency Fsys.\n  XBUS: 8-bit parallel external bus, compatible with standard MCS51 bus, used to connect off-chip SRAM memory or other peripherals, support direct 15-bit address or ALE multiplexed lower 8-bit address, support 4 kinds of bus access speed.\n  GPIO: Supports up to 45 GPIO pins (including XI/XO and RST and USB signal pins), 3.3V voltage output, and supports 5V withstand voltage input except P1.0~P1.7, XI, XO, RST.\n  Interrupt: Supports 14 sets of interrupt sources, including 6 sets of interrupts compatible with standard MCS51 (INT0, T0, INT1, T1, UART0, T2), and extended 8 sets of interrupts (SPI0, TMR3, USB, ADC, UART1, PWM1) , GPIO, WDOG), where the GPIO interrupt can be selected from 7 pins.\n  Watch-Dog: 8-bit preset watchdog timer WDOG, support for timed interrupts.\n  Reset: Supports 4 kinds of reset signal sources, built-in power-on reset, support software reset and watchdog overflow reset, optional external input input reset.\n  Clock: Built-in 12MHz clock source, external crystal can be supported by multiplexed GPIO pin, built-in PLL is used to generate USB clock and system frequency Fsys of required frequency.\n  Power: Built-in 5V to 3.3V low dropout voltage regulator with internal working voltage of 3.3V and support for external 3.3V or 5V power input. Support low-power sleep, support USB, UART0, UART1, SPI0 and some GPIO external wake-up.\n  The chip has a unique ID number built in, supporting ID numbers and verification.\n  "});index.add({'id':2,'href':'/docs/3-package/','title':"3. Package",'content':"8-bit enhanced USB microcontroller CH559 3. Package Package Description    Package Package width Pin spacing Package description Part No.     LQFP-48 7x7 mm 0.5mm / 19.7mil Standard LQFP48 footprint CH559L   SSOP-20 5.3mm 0.65mm / 25mil Ultra-small 20-footprint CH559T    "});index.add({'id':3,'href':'/docs/4-pin_descriptions/','title':"4. Pin descriptions",'content':"8-bit enhanced USB microcontroller CH559 4. Pin descriptions CH559L/T pin definitions.   Pin number Pin name (function after reset) Alternate functions Alternate functions description   SSOP-20 LQFP-48   1941VIN5V5The 5V external power input of the internal 5V-3.3V voltage regulator requires an external 0.1uF power supply decoupling capacitor.   2042VDD33VDD/VCCInternal voltage regulator output and internal 3.3V working power input. When the power supply voltage is less than 3.6V, connect VIN5 to input external power supply. When the power supply voltage is greater than 3.6V, connect 3.3uF power supply decoupling capacitor.   1818GNDVSSCommon ground terminal.   --40P0.0AD0/UDTRP0 port: The default is an 8-bit open-drain bidirectional port. You can enable the internal pull-up resistor to be turned into a quasi-bidirectional port by setting P0_PU.\nP0 temporarily switches to push-pull output as a bidirectional data bus AD0~AD7 when accessing the external bus, or outputs the lower 8 bits of the address as needed when accessing the external bus in multiplexed address mode.\nUDTR, URTS: Modem signal output of UART1.\nUCTS, UDSR, URI, UDCD: UART1 modem signal input.\nRXD_, TXD_: RXD, TXD pin mapping.\n   --39P0.1AD1/URTS   1738P0.2AD2/RXD_   1637P0.3AD3/TXD_   --36P0.4AD4/UCTS   --35P0.5AD5/UDSR   --34P0.6AD6/URI   --33P0.7AD7/UDCD   --43P1.0AIN0/T1/CAP1AIN0~AIN7: 8-channel ADC analog signal input.\nT2: External count input/clock output of timer/counter 2.\nT2EX: Timer/Counter 2 Reload/Capture Input.\nCAP1, CAP2: Capture input of timer/counter 2 1, 2.\nCAP3/PWM3: Timer/Event Counter 3 Capture Input/PWM Output.\nSCS, MOSI, MISO, SCK: SPI0 interface, SCS is the chip select input, MOSI is the master output/slave input, MISO is the master input/slave output, and SCK is the serial clock.\n   --44P1.1AIN1/T2EX/CAP2   145P1.2AIN2/PWM3/CAP3   --46P1.3AIN3   247P1.4AIN4/SCS   348P1.5AIN5/MOSI   41P1.6AIN6/MISO   52P1.7AIN7/SCK   --21P2.0A8When P2 accesses the external bus, it will automatically switch to the push-pull output temporarily, and output the upper 8 bits of the address A8~A15 as needed.\nMOSI1, MISO1, SCK1: SPI1 interface, MOSI1 is the master output, MISO1 is the master input, and SCK1 is the serial clock output.\nPWM1, PWM2: PWM1 output, PWM2 output.\nTNOW: UART1 is sending an output indication.\nT2EX_/CAP2_: T2EX/CAP2 pin mapping.\nRXD1, TXD1: UART1 serial data input, serial data output.\nDA7: Output address A7 when accessing the external bus in direct address mode.\n   --22P2.1MOSI1/A9   --23P2.2MISO1/A10   --24P2.3SCK1/A11   --25P2.4PWM1/A12   1126P2.5TNOW/PWM2/A13/T2EX_/CAP2_   1227P2.6RXD1/A14   1328P2.7TXD1/DA7/A15   --4P3.0RXDRXD, TXD: UART0 serial data input, serial data output.\nINT0, INT1: External interrupt 0, External interrupt 1 input.\nLED0, LED1, LEDC: LED serial data 0, 1, clock output.\n!A15: External bus address A15 Inverting output for chip select.\nT0, T1: Timer 0, Timer 1 External input.\nXCS0: External bus address 4000h~7FFFh Chip select output.\nDA6: Output address A6 when accessing the external bus in direct address mode.\nWR, RD: External bus write signal, read signal.\n   --7P3.1TXD   78P3.2LED0/INT0   --9P3.3LED1/!A15/INT1   810P3.4LEDC/XCS0/T0   --11P3.5DA6/T1   --12P3.6WR   --13P3.7RD   --20P4.0LED2/A0/RXD1_A0~A5: Outputs the lower 6-bit address A0~A5 when accessing the external bus in direct address mode.\nLED2, LED3: LED serial data 2, 3 output.\nRXD1_, TNOW_/TXD1_: RXD1, TNOW/TXD1 pin mapping.\nPWM3_/CAP3_: PWM3/CAP3 pin mapping.\nPWM1_, PWM2_: PWM1, PWM2 pin mapping.\nXI, XO: external crystal oscillator input, inverting output.\nSCS_, SCK_: SPI0 Chip Select SCS, SCK pin mapping.\n   --19P4.1A1   --15P4.2PWM3_/CAP3_/A2   --14P4.3PWM1_/A3   --6P4.4LED3/TNOW_/TXD1_/A4   --5P4.5PWM2_/A5   916P4.6XI/SCS_   1017P4.7X0/SCK_   1532P5.0DMDM, DP: USB host HUB0 or D-, D+ signal terminal of USB device.   1431P5.1DP   --30P5.4HM/ALE/XBXB, XA: B/inverting, A/in-phase signal terminal of iRS485.\nALE: Address latch signal output in multiplexed address mode.\n!A15: External bus address A15 Inverting output for chip select.\nHM, HP: The USB host extends the D- and D+ signals of HUB1.\n   --29P5.5HP/!A15/XA   63P5.7RSTExternal reset input with built-in pull-down resistor.  "});index.add({'id':4,'href':'/docs/5-sfr/','title':"5. Special function register SFR",'content':"5. Special function register SFR The following abbreviations may be used in describing the registers in this manual:\n   Abbreviation Description     RO Indicates access type: read only   WO Indicates the access type: write only, the value read is invalid   RW Indicates access type: readable and writable   h End with hexadecimal number   b Expressed as a binary number    5.1 SFR profile and address distribution The CH559 uses the special function registers SFR and xSFR to control, manage, and set the operating mode.\nThe SFR occupies the 80h-FFh address range of the internal data storage space and can only be accessed by direct address mode instructions.\nRegisters whose address is x0h or x8h are bit-addressable, which avoids changing the value of other bits when accessing a specific bit; registers other than a multiple of 8 can only be accessed byte by byte.\nSome SFRs can only write data in safe mode, but are read-only in non-secure mode, such as: GLOBAL_CFG, PLL_CFG, CLOCK_CFG, SLEEP_CTRL, WAKE_CTRL.\nSome SFRs have one or more aliases, such as: SPI0_CK_SE/SPI0_S_PRE, UDEV_CTRL/UHUB0_CTRL, UEP1_CTRL/UH_SETUP, UEP2_CTRL/UH_RX_CTRL, UEP2_T_LEN/UH_EP_PID, UEP3_CTRL/UH_TX_CTRL, UEP3_T_LEN/UH_TX_LEN, P5_PIN/P4_CFG.\nPartial addresses correspond to multiple independent SFRs, for example: TL2/T2CAP1L, TH2/T2CAP1H, SAFE_MOD/CHIP_ID, T3_COUNT_L/T3_CK_SE_L, T3_COUNT_H/T3_CK_SE_H, SER1_FIFO/SER1_RBR/SER1_THR/SER1_DLL, SER1_IER/SER1_DLM, SER1_IIR/SER1_FCR, SER1_ADDR/SER1_DIV, ROM_CTRL/ROM_STATUS.\nxSFR occupies the 2440h-298Fh address range of the xdata type of the external data storage space, or the 40H-8Fh address range of the pdata type. xSFR can only be accessed in bytes by indirect addressing via the MOVX instruction.\nThe default is based on the DPTR pointer; however, after bXIR_XSFR is set, the faster R0 or R1 can be used as a pdata type pointer to access xSFRs named pU* and pLED_*.\nSome xSFRs have one or more aliases, for example: UEP2_3_MOD/UH_EP_MOD, UEP2_DMA_H/UH_RX_DMA_H, UEP2_DMA_L/UH_RX_DMA_L, UEP2_DMA/UH_RX_DMA, UEP3_DMA_H/UH_TX_DMA_H, UEP3_DMA_L/UH_TX_DMA_L, UEP3_DMA/UH_TX_DMA.\nPartial addresses correspond to multiple independent xSFRs, for example: LED_DATA/LED_FIFO_CN.\nThe CH559 contains all the registers of the 8051 standard SFR, and other device control registers have been added. The specific SFR is shown in the table below.\n Table 5.1 Special Function Register Table\n Remarks: (1), Text in red means it can be addressed by bit; (2), the following is the corresponding description of the color box.\n  Color Description  Register address SPI0 related register ADC related register USB related register Timer/Counter 2 Related Registers Port setting related register SPI1 related register PWM1 and PWM2 related registers UART1 related register Timer/Counter 0 and 1 related registers Flash-ROM related register  5.2 SFR types and reset values   Function typeNameAddressDescriptionReset value  System settings registerBF0hB register0000 0000b ACCE0haccumulator0000 0000b PSWD0hProgram status register0000 0000b GLOBAL_CFGB1hGlobal configuration register (in the bootloader state)1110 0000b Global configuration register (in application state)1100 0000b CHIP_IDA1hChip ID (read only)0101 1001b SAFE_MODA1hSafe mode control register (write only)0000 0000b DPH83hData address pointer is 8 bits high0000 0000b DPL82hData address pointer is lower 8 bits0000 0000b DPTR82hDPL and DPH form a 16-bit SFR0000h SP81hStack pointer0000 0111b Clock, sleep, and\npower control registersWDOG_COUNTFFhWatchdog count register0000 0000b RESET_KEEPFEhReset holding register (in power-on reset state)0000 0000b WAKE_CTRLEBhSleep wake control register0000 0000b SLEEP_CTRLEAhSleep control register0000 0000b CLOCK_CFGB3hSystem clock configuration register1001 1000b PLL_CFGB2hPLL clock configuration register1101 1000b PCON87hPower control register (in power-on reset state)0001 0000b Interrupt control registerIP_EXE9hExtended interrupt priority control register0000 0000b IE_EXE8hExtended interrupt enable register0000 0000b GPIO_IECFhGPIO interrupt enable register0000 0000b IPB8hInterrupt priority control register0000 0000b IEA8hInterrupt enable register0000 0000b Flash-ROM registerROM_DATA_H8Fhflash-ROM data register high bytexxxx xxxxb ROM_DATA_L8EhFlash-ROM data register low bytexxxx xxxxb ROM_DATA8EhROM_DATA_L and ROM_DATA_H form a 16-bit SFRxxxxh ROM_STATUS86hflash-ROM status register (read only)1000 0000b ROM_CTRL86hflash-ROM control register (write only)0000 0000b ROM_ADDR_H85hflash-ROM address register high bytexxxx xxxxb ROM_ADDR_L84hFlash-ROM address register low bytexxxx xxxxb ROM_ADDR84hROM_ADDR_L and ROM_ADDR_H form a 16-bit SFRxxxxh Port setting registerXBUS_SPEEDFDhExternal bus speed configuration register1111 1111b XBUS_AUXFDhExternal bus auxiliary setting register0000 0000b PIN_FUNCCEhPin function select register0000 0000b P4_CFGC7hP4 port configuration register0000 0000b P5_INC7hP5 port input register (read only)0000 0000b PORT_CFGC6hPort configuration register0000 1111b P0_PUC5hP0 port pull-up enable register (En_P0_Pullup=0)0000 0000b P0 port pull-up enable register (En_P0_Pullup=1)1111 1111b P0_DIRC4hP0 port direction control register0000 0000b P4_PUC3hP4 port pull-up enable register1111 1111b P4_DIRC2hP4 port direction control register0000 0000b P4_INC1hP4 port input register (read only)1111 1111b P4_OUTC0hP4 port output register0000 0000b P3_PUBFhP3 port direction control register1111 1111b P3_DIRBEhP3 port pull-up enable register0000 0000b P2_PUBDhP2 port pull-up enable register1111 1111b P2_DIRBChP2 port direction control register0000 0000b P1_PUBBhP1 port pull-up enable register1111 1111b P1_DIRBAhP1 port direction control register0000 0000b P1_IEB9hP1 port input enable register1111 1111b P3B0hP3 port input and output registers1111 1111b P2A0hP2 port input and output registers1111 1111b P190hP1 port input and output registers1111 1111b P080hP0 port input and output registers1111 1111b Timer/Counter 0 and 1 registersTH18DhTimer1 count high bytexxxx xxxxb TH08ChTimer0 count high bytexxxx xxxxb TL18Bh3Timer1 count low bytexxxx xxxxb TL08AhTimer0 count low bytexxxx xxxxb TMOD89hTimer0/1 mode register0000 0000b TCON88hTimer0/1 Control Register0000 0000b UART0 registerSBUF99hUART0 data registerxxxx xxxxb SCON98hUART0 control register0000 0000b Timer/Counter 2 RegistersTH2CDhTimer2 counter high byte0000 0000b TL2CChTimer2 counter low byte0000 0000b T2COUNTCChTL2 and TH2 form a 16-bit SFR0000h T2CAP1HCDhTimer2 capture 1 data high byte (read only)xxxx xxxxb T2CAP1LCChTimer2 capture 1 data low byte (read only)xxxx xxxxb T2CAP1CChT2CAP1L and T2CAP1H form a 16-bit SFRxxxxh RCAP2HCBhCount reload/capture 2 data register high byte0000 0000b RCAP2LCAhCount reload/capture 2 data register low byte0000 0000b RCAP2CAhRCAP2L and RCAP2H form a 16-bit SFR0000h T2MODC9hTimer2 mode register0000 0000b T2CONC8hTimer2 Control Register0000 0000b Timer/counter 3 registersT3_FIFO_HAFhTimer3 FIFO high bytexxxx xxxxb T3_FIFO_LAEhTimer3 FIFO low bytexxxx xxxxb T3_FIFOAEhT3_FIFO_L and T3_FIFO_H form a 16-bit SFRxxxxh T3_DMA_AHADhDMA current buffer address high byte0000 xxxxb T3_DMA_ALAChDMA current buffer address low bytexxxx xxx0b T3_DMAAChT3_DMA_AL and T3_DMA_AH form a 16-bit SFR0xxxh T3_DMA_CNABhDMA residual count register0000 0000b T3_CTRLAAhTimer3 Control Register0000 0010b T3_STATA9hTimer3 Status Register0000 0000b T3_END_HA7hTimer3 counts the final high bytexxxx xxxxb T3_END_LA6hTimer3 counts the final low bytexxxx xxxxb T3_ENDA6hT3_END_L and T3_END_H form a 16-bit SFRxxxxh T3_COUNT_HA5hTimer3 current count high byte (read only)0000 0000b T3_COUNT_LA4hTimer3 current count low byte (read only)0000 0000b T3_COUNTA4hT3_COUNT_L and T3_COUNT_H form a 16-bit SFR0000h T3_CK_SE_HA5hTimer3 clock divider setting high byte0000 0000b T3_CK_SE_LA4hTimer3 clock divider sets the low byte0010 0000b T3_CK_SEA4hT3_CK_SE_L and T3_CK_SE_H form a 16-bit SFR0020h T3_SETUPA3hTimer3 setup register0000 0100b PWM1 and PWM2 registersPWM_CYCLE9FhPWM cycle period registerxxxx xxxxb PWM_CK_SE9EhPWM clock divider setting register0000 0000b PWM_CTRL9DhPWM control register0000 0010b PWM_DATA9ChPWM1 data registerxxxx xxxxb PWM_DATA29BhPWM2 data registerxxxx xxxxb SPI0 registerSPI0_SETUPFChSPI0 setting register0000 0000b SPI0_S_PREFBhSPI0 slave mode preset data register0010 0000b SPI0_CK_SEFBhSPI0 clock divider setting register0010 0000b SPI0_CTRLFAhSPI0 control register0000 0010b SPI0_DATAF9hSPI0 data transceiver registerxxxx xxxxb SPI0_STATF8hSPI0 status register0000 1000b SPI1 registerSPI1_CK_SEB7hSPI1 clock divider setting register0010 0000b SPI1_CTRLB6hSPI1 control register0000 0010b SPI1_DATAB5hSPI1 data transceiver registerxxxx xxxxb SPI1_STATB4hSPI1 status register0000 1000b UART1 registerSER1_DLL9AhUART1 Baud Rate Divisor Latch Low Bytexxxx xxxxb SER1_FIFO9AhUART1 data FIFO read and write registersxxxx xxxxb SER1_DIV97hUART1 prescaler divisor register0xxx xxxxb SER1_ADDR97hUART1 bus address preload register1111 1111b SER1_MSR96hUART1 Modem MODEM Status Register (Read Only)1111 0000b SER1_LSR95hUART1 line status register (read only)0110 0000b SER1_MCR94hUART1 Modem MODEM Control Register0000 0000b SER1_LCR93hUART1 line control register0000 0000b SER1_IIR92hUART1 Interrupt Identification Register (Read Only)0000 0001b SER1_FCR92hFIFO control register (write only)0000 0000b SER1_DLM91hUART1 baud rate divisor latch high byte1000 0000b SER1_IER91hUART1 interrupt enable register0000 0000b ADC registerADC_EX_SWF7hADC Extended Analog Switch Control Register0000 0000b ADC_SETUPF6hADC setup register0000 1000b ADC_FIFO_HF5hFIFO high byte of ADC (read only)0000 0xxxb ADC_FIFO_LF4hADC FIFO low byte (read only)xxxx xxxxb ADC_FIFOF4hADC_FIFO_L and ADC_FIFO_H form a 16-bit SFR0xxxh ADC_CHANNF3hADC channel select register0000 0000b ADC_CTRLF2hADC control register0000 0000b ADC_STATF1hADC status register0000 0100b ADC_CK_SEEFhADC clock divider setting register0001 0000b ADC_DMA_CNEEhDMA residual count register0000 0000b ADC_DMA_AHEDhDMA current buffer address high byte0000 xxxxb ADC_DMA_ALEChDMA current buffer address low bytexxxx xxx0b ADC_DMAEChADC_DMA_AL and ADC_DMA_AH form a 16-bit SFR0xxxh USB registerUSB_DMA_AHE7hDMA current buffer address high byte (read only)000x xxxxb USB_DMA_ALE6hDMA current buffer address low byte (read only)xxxx xxx0b USB_DMAE6hUSB_DMA_AL and USB_DMA_AH form a 16-bit SFRxxxxh UHUB1_CTRLE5hUSB host HUB1 port control register1100 x000b UHUB0_CTRLE4hUSB host HUB0 port control register0100 x000b UDEV_CTRLE4hUSB Device Port Control Register0100 x000b USB_DEV_ADE3hUSB Device Address Register0000 0000b USB_CTRLE2hUSB Control Register0000 0110b USB_INT_ENE1hUSB Interrupt Enable Register0000 0000b UEP4_T_LENDFhEndpoint 4 Transmit Length Register0xxx xxxxb UEP4_CTRLDEhEndpoint 4 Control Register0000 0000b UEP0_T_LENDDhEndpoint 0 Transmit Length Register0xxx xxxxb UEP0_CTRLDChEndpoint 0 Control Register0000 0000b USB_HUB_STDBhSB Host HUB Port Status Register (Read Only)0000 0000b USB_MIS_STDAhSB Miscellaneous Status Register (Read Only)xx10 1000b USB_INT_STD9hUSB Interrupt Status Register (Read Only)00xx xxxxb USB_INT_FGD8hUSB Interrupt Flag Register0010 0000b UEP3_T_LEND7hEndpoint 3 Transmit Length Register0xxx xxxxb UH_TX_LEND7hUSB host send length register0xxx xxxxb UEP3_CTRLD6hEndpoint 3 Control Register0000 0000b UH_TX_CTRLD6hUSB host transmit endpoint control register0000 0000b UEP2_T_LEND5hEndpoint 2 Transmit Length Register0000 0000b UH_EP_PIDD5hUSB Host Token Setting Register0000 0000b UEP2_CTRLD4hEndpoint 2 Control Register0000 0000b UH_RX_CTRLD4hUSB host receive endpoint control register0000 0000b UEP1_T_LEND3hEndpoint 1 Transmit Length Register0xxx xxxxb UEP1_CTRLD2hEndpoint 1 Control Register0000 0000b UH_SETUPD2hUSB Host Auxiliary Settings Register0000 0000b USB_RX_LEND1hUSB Receive Length Register (Read Only)0xxx xxxxb USB xSFR registerUEP4_1_MOD2446hEndpoint 1, 4 mode control register0000 0000b UEP2_3_MOD2447hEndpoint 2, 3 Mode Control Register0000 0000b UH_EP_MOD2447hUSB Host Endpoint Mode Control Register0000 0000b UEP0_DMA_H2448hEndpoints 0 and 4 Buffer Start Address High Bytes000x xxxxb UEP0_DMA_L2449hEndpoints 0 and 4 Buffer Start Address Low Bytexxxx xxx0b UEP0_DMA2448hUEP0_DMA_L and UEP0_DMA_H form a 16-bit SFRxxxxh UEP1_DMA_H244AhEndpoint 1 Buffer Start Address High Byte000x xxxxb UEP1_DMA_L244BhEndpoint 1 Buffer Start Address Low Bytexxxx xxx0b UEP1_DMA244AhUEP1_DMA_L and UEP1_DMA_H form 16-bit SFRxxxxh UEP2_DMA_H244ChEndpoint 2 Buffer start address high byte000x xxxxb UEP2_DMA_L244DhEndpoint 2 Buffer Start Address Low Bytexxxx xxx0b UEP2_DMA244ChUEP2_DMA_L and UEP2_DMA_H form 16-bit SFRxxxxh UH_RX_DMA_H244ChUSB host receive buffer start address high byte000x xxxxb UH_RX_DMA_L244DhUSB host receive buffer start address low bytexxxx xxx0b UH_RX_DMA244ChUH_RX_DMA_L and UH_RX_DMA_H form 16-bit SFRxxxxh UEP3_DMA_H244EhEndpoint 3 Buffer start address high byte000x xxxxb UEP3_DMA_L244FhEndpoint 3 Buffer Start Address Low Bytexxxx xxx0b UEP3_DMA244EhUEP3_DMA_L and UEP3_DMA_H form 16-bit SFRxxxxh UH_TX_DMA_H244EhUSB host transmit buffer start address high byte000x xxxxb UH_TX_DMA_L244FhUSB host send buffer start address low bytexxxx xxx0b UH_TX_DMA244EhUH_TX_DMA_L and UH_TX_DMA_H form a 16-bit SFRxxxxh pU*254*hAfter bXIR_XSFR is set to 1, this name is used to address the above xSFR with pdata type, which is faster than xdata type addressing. LED Control Card xSFR RegisterLED_STAT2880hLED Status Register010x 0000b LED_CTRL2881hLED Control Register0000 0010b LED_FIFO_CN2882hFIFO Count Status Register (Read Only)0000 0000b LED_DATA2882hLED data register (write only)xxxx xxxxb LED_CK_SE2883hLED Clock Divider Setting Register0001 0000b LED_DMA_AH2884hDMA current buffer address high byte000x xxxxb LED_DMA_AL2885hDMA Current buffer address low bytexxxx xxx0b LED_DMA2884hLED_DMA_AL and LED_DMA_AH Compose 16-bit SFRxxxxh LED_DMA_CN2886hLED DMA Remaining Count Registerxxxx xxxxb LED_DMA_XH2888hDMA Current auxiliary buffer address high byte000x xxxxb LED_DMA_XL2889hDMA Current auxiliary buffer address low bytexxxx xxx0b LED_DMA_X2888hLED_DMA_XL and LED_DMA_XH form a 16-bit SFRxxxxh pLED_*298*hAfter bXIR_XSFR is set to 1, this name is used to address the above xSFR with pdata type, which is faster than xdata type addressing.  5.3 General purpose 8051 register  Table 5.3.1 General 8051 Register List\n   NameAddressDescriptionReset value  BF0hB register00h A, ACCE0haccumulator00h PSWD0hprogram status register00h GLOBAL_CFGB1hGlobal configuration register (in the bootloader state)E0h Global configuration register (in application state)C0h CHIP_IDA1hChip ID Identifier (Read Only)59h SAFE_MODA1hSafety Mode Control Register (Write Only)00h PCON87hpower control register (in power-on reset state)10h DPH83hdata address pointer high 8 bit00h DPL82hdata address pointer low 8 bits00h DPTR82hDPL and DPH form 16-bit SFR0000h SP81hstack pointer07h  B register (B):   BitNameAccessDescriptionReset value  [7:0]BRWArithmetic operation registers, mainly used for multiplication and division, bit-addressable00h  A accumulator (A, ACC):   BitNameAccessDescriptionReset value  [7:0]A/ACCRWArithmetic accumulator, bit addressable00h  Program Status Register (PSW):   BitNameAccessDescriptionReset value  7CYRWCarry flag: Used to record the carry or borrow of the most significant bit when performing arithmetic and logic operations.\nWhen the 8-bit addition is performed, the most significant bit is set, otherwise it is cleared.\nwhen 8-bit subtraction is performed If the borrow is borrowed, the bit is set, otherwise it is cleared.\nThe logic instruction can make the bit bit or clear.\n0 6ACRWAuxiliary carry flag: When recording and subtracting, the lower 4 bits have a carry or borrow from the upper 4 bits, AC is set, otherwise cleared.0 5F0RWUniversal flag bit addressable by bit 0: User can define it himself, can be cleared or set by software0 4RS1RWRegister bank select bit high0 3RS0RWRegister bank select bit low0 2OVRWOverflow flag: When adding or subtracting, the operation result exceeds 8 binary digits, then OV is set to 1, the flag overflows, otherwise cleared 00 1F1RWUniversal flag bit addressable by bit 1: User can define it, can be cleared or set by software0 0PR0Parity flag: Record the parity of 1 in accumulator A after the execution of the instruction. P1 for odd number 1 and P for even number 10  The state of the processor is stored in the status register PSW and the PSW supports bitwise addressing. The status word includes the carry flag, the auxiliary carry flag for BCD code processing, the parity flag, the overflow flag, and RS0 and RS1 for the working register bank selection. The area in which the working register set is located can be accessed either directly or indirectly.\n Table 5.3.2 RS1 and RS0 Working Register Group Selection Table\n   RS1RS0Working register set  00Group 0 (00h-07h) 01Group 1 (08h-0Fh) 10Group 2 (10h-17h) 11Group 3 (18h-1Fh)   Table 5.3.3 Operations that affect the flag bit (X indicates that the flag bit is related to the operation result)\n   OperationCYOVAC  ADDXXX ADDCXXX SUBBXXX MUL0X DIV0X DA AX RRC AX RLC AX CJNEX SETB C1 CLR C0 CPL CX MOV C, bitX ANL C, bitX ANL C,/bitX ORL C, bitX ORL C,/bitX  Data Address Pointer (DPTR):   BitNameAccessDescriptionReset value  [7:0]DPLRWData pointer low byte00h [7:0]DPHRWData pointer high byte00h  DPL and DPH form a 16-bit data pointer DPTR for accessing xSFR, xBUS, xRAM data memory or program memory. The actual DPTR corresponds to the physical 16-bit data pointers of DPTR0 and DPTR1, which are dynamically selected by DPS in XBUS_AUX.\nStack pointer (SP):   BitNameAccessDescriptionReset value  [7:0]SPRWStack pointer, mainly used for program calls and interrupt calls, and data in and out of the stack07h  Stack specific functions: protect endpoints and protect the site, and manage them on a first-come, first-out basis. When the stack is pushed, the SP pointer is automatically incremented by 1, and the data or breakpoint information is saved. When the stack is taken, the SP pointer points to the data unit, and the SP pointer is automatically decremented by 1. The initial value of the SP after reset is 07h, and the corresponding default stack storage starts at 08h.\n5.4 Special registers Global configuration register (GLOBAL_CFG), writable only in safe mode:\n  BitNameAccessDescriptionReset value  [7:6]ReservedROFixed value 1111b 5bBOOT_LOADROThe Boot loader status bit is used to distinguish between the ISP bootloader status or the application state: set when the power is turned on, and cleared to 0 when the software is reset. For chips with an ISP bootloader, this bit is 1 indicates that the software has never been reset, usually the ISP bootloader state that was run after power-up. this bit is 0 indicating that the software has been reset, usually the application state\n1 4bSW_RESETRWSoftware reset control bit: Set to 1 to cause software reset, hardware auto-zero0 3bCODE_WERWFlash-ROM write enable bit: This bit is 0 for write protection; 1 for Flash-ROM writable erasable0 2bDATA_WERWDataFlash area write enable bit of Flash-ROM: This bit is 0 for write protection; 1 is for DataFlash area to be erasable and erasable0 1bXIR_XSFRRWMOVX_@R0/R1 instruction access range control bits:\nThis bit is 0 to allow access to all xdata regions xRAM/xBUS/xSFR.\nThis bit is 1 for access to xSFR and cannot access xRAM/xBUS\n0 0bWDOG_ENRWWatchdog reset enable bit: This bit is 0. The watchdog is only used as a timer. this bit is 1 to allow a watchdog reset when the timer overflows.0  Chip ID (CHIP_ID):   BitNameAccessDescriptionReset value  [7:0]CHIP_IDROFixed value 59h for identification chip59h  Safe Mode Control Register (SAFE_MOD):   BitNameAccessDescriptionReset value  [7:0]SAFE_MODWOUsed to enter or terminate safe mode00h  Some SFRs can only write data in safe mode, and are always read-only in non-secure mode. Steps to enter safe mode:\n write 55h to the register. then write AAh to the register. After that, about 13 to 23 system main frequency cycles are in safe mode, and one or more security class SFRs or ordinary SFRs can be rewritten during the validity period. automatically terminate the safe mode after the above validity period. Or write any value to this register to terminate the safe mode early.  "});index.add({'id':5,'href':'/docs/6-memory_structure/','title':"6. Memory structure",'content':"6. Memory structure 6.1 Memory space CH559 addressing space is divided into program storage space, internal data storage space, and external data storage space.\n Figure 6.1 Memory Structure\n 6.2 Program Storage Space The program memory space is 64KB. As shown in Figure 6.1, it is all used for flash-ROM, including Code Flash area for saving instruction code, Data Flash area for saving non-volatile data, and Configuration Information area for configuration information.\nThe Data Flash address range is F000h to F3FFH. It supports single-byte read (8-bit), double-byte write (16-bit), and block erase (1K byte) operations. The data remains unchanged after the chip is powered off. Make Code Flash.\nCode Flash includes application code for low address areas and bootstrap code for high address areas. You can also combine these two areas and Data Flash to hold a single application code.\nConfiguration Information Configuration Information A total of 16 bits of data, set by the programmer as needed, refer to Table 6.1.\n Table 6.2 Description of flash-ROM configuration information\n   BitNameDescriptionReset value  15Code_ProtectCode and data protection mode in flash-ROM:\n0-Prohibit the programmer to read, the program is confidential; 1-Allow readout0/1 14No_Boot_LoadEnable BootLoader boot code startup mode:\n0-started from the 0000h address application.\n1-start from the bootloader of the F400h address1 13En_Long_ResetEnable additional delay reset during power-on reset:\n0-standard short reset; 1-wide reset, additional 87mS reset time0 12XT_OSC_StrongSelect the external drive capability of the crystal oscillator: 0-standard; 1-enhanced0 11En_P5.7_RESETEnable P5.7 as a manual reset input pin: 0-disable; 1-enable RST1 10En_P0_PullupEnable internal pull-up resistor for port P0 during system reset:\n0-Pull-up resistor disabled after reset.\n1-Pull-up resistor enabled after reset1 9Must_1(Automatically set to 1 by the programmer as needed)1 8Must_0(automatically set to 0 by the programmer as needed)0 [7:0]All_1(Automatically set to FFh by the programmer as needed)FFh  6.3 Data Storage Space The internal data storage space is 256 bytes in total. As shown in Figure 6.1, it is used for SFR and iRAM. iRAM is used for stack and fast data temporary storage. It can be subdivided into working registers R0-R7, bit variables bdata, bytes. Variable data, idata, etc.\nThe external data storage space is 64KB in total, as shown in Figure 6.1, and partially used for 6KB on-chip expansion of xRAM and xSFR. Except for the two reserved areas, the remaining 4000h to FFFFh address range is the external bus area.\n6.4 flash-ROM register  Table 6.4 List of flash-ROM operation registers\n   NameAddressDescriptionReset value  ROM_DATA_H8Fhflash-ROM data register high bytexxh ROM_DATA_L8Ehflash-ROM data register low bytexxh ROM_DATA8EhROM_DATA_L and ROM_DATA_H form a 16-bit SFRxxxxh ROM_STATUS86hflash-ROM status register (read only)80h ROM_CTRL86hflash-ROM control register (write only)00h ROM_ADDR_H85hflash-ROM address register high bytexxh ROM_ADDR_L84hflash-ROM address register low bytexxh ROM_ADDR84hROM_ADDR_L and ROM_ADDR_H form a 16-bit SFRxxxxh  flash-ROM address register (ROM_ADDR):   BitNameAccessDescriptionReset value  [7:0]ROM_ADDR_HRWFlash-ROM address high bytexxh [7:0]ROM_ADDR_LRWFlash-ROM address low byte, only supports even addressxxh  flash-ROM data register (ROM_DATA):   BitNameAccessDescriptionReset value  [7:0]ROM_DATA_HRWflash-ROM data to be written high bytexxh [7:0]ROM_DATA_LRWflash-ROM data to be written low bytexxh  flash-ROM control register (ROM_CTRL):   BitNameAccessDescriptionReset value  [7:0]ROM_CTRLW0flash-ROM control register00h  flash-ROM status register (ROM_STATUS):   BitNameAccessDescriptionReset value  7ReservedR0Reserved1 6bROM_ADDR_OKR0flash-ROM operation address valid status bit:\nIf the bit is 0, the parameter is invalid; 1 means the address is valid.0 [5:2]ReservedR0Reserved0000b 1bROM_CMD_ERRR0flash-ROM operation command error status bit:\nA bit of 0 indicates that the command is valid. A value of 1 indicates an unknown command.0 0bROM_CMD_TOUTR0flash-ROM operation result status bit:\nA bit of 0 indicates that the operation was successful. A value of 1 indicates that the operation timed out.0  6.5 flash-ROM operation steps   Erase the flash-ROM and change all the data bits in the target block to 1:\n enable the security mode, SAFE_MOD = 55h; SAFE_MOD = 0AAh; set the global configuration register GLOBAL_CFG to enable write enable (bCODE_WE or bDATA_WE corresponds to code or data); set the address register ROM_ADDR, write 16-bit target address, the actual only high 6 bits are valid; Set the operation control register ROM_CTRL to 0A6h to perform the block erase operation, and the program will automatically pause during the operation; After the operation is completed, the program resumes operation. At this time, the status register ROM_STATUS can be queried to check the operation status; if multiple blocks are to be erased, the steps (3), (4), and (5) are repeated; enter safe mode again, SAFE_MOD = 55h; SAFE_MOD = 0AAh; Set the global configuration register GLOBAL_CFG to enable write protection (bCODE_WE=0, bDATA_WE=0).    Write flash-ROM to change part of the data bits in the target double byte from 1 to 0:\n enable the security mode, SAFE_MOD = 55h; SAFE_MOD = 0AAh; set the global configuration register GLOBAL_CFG to enable write enable (bCODE_WE or bDATA_WE corresponds to code or data); set the address register ROM_ADDR, write 16-bit target address, the actual only 15 high; set the data register ROM_DATA, write 16 bits of data to be written, steps (3), (4) can be reversed; Set the operation control register ROM_CTRL to 09Ah to perform the write operation, and the program will automatically suspend the operation during the operation; After the operation is completed, the program resumes operation. At this time, the status register ROM_STATUS can be queried to check the operation status; if multiple data is to be written, the steps (3), (4), (5), and (6) are repeated; enter safe mode again, SAFE_MOD = 55h; SAFE_MOD = 0AAh; Set the global configuration register GLOBAL_CFG to enable write protection (bCODE_WE=0, bDATA_WE=0).    read flash-ROM:\n Read the code or data of the target address directly using the MOVC instruction or by a pointer to the program memory space.    6.6 On-board programming and ISP downloads When the configuration information Code_Protect=1, the code and data in the CH559 chip flash-ROM can be read and written by the external programmer through the synchronous serial interface; when the configuration information Code_Protect=0, the code and data in the flash-ROM are protected. Can not be read, but can be erased, and re-powered after erasing to release code protection.\nWhen the CH559 chip is pre-installed with the BootLoader bootloader, the CH559 can support multiple ISP download methods such as USB or asynchronous serial port to load the application; but without the bootloader, the CH559 can only be written to the bootloader by an external dedicated programmer. Or an application. In order to support on-board programming, five connection pins between CH559 and the programmer need to be reserved in the circuit.\n Table 6.6.1 Connection Pins to the Programmer\n   PinGPIOPin description  RSTP5.7Reset control pin in programming state, high level allows entry into programming state SCSP1.4Chip select input pin in programming state, default high level, active low SCKP1.7Clock input pin in programming state MOSIP1.5Data input pin in programming state MISOP1.6Data output pin in programming state  6.7 chip unique ID number Each microcontroller is shipped with a unique ID number, the chip identification number. The ID data and its checksum are 8 bytes in total, and are stored in the area where the offset address of the dedicated read-only memory is 20h. It can be obtained by reading Code Flash similarly during the period when E_DIS is 1 to close the global interrupt. Please refer to the C language example program GETID.C for operation.\n Table 6.7.1 Chip ID Address Table\n   Offset addressID data description  20h, 21hID first word data, followed by the lowest byte and the next lowest byte of the ID number 22h, 23hID second word data, followed by the next highest byte of the ID number, high byte 24h, 25hID last word data, followed by the next highest byte and highest byte of the 48-bit ID number 26h, 27h16-bit cumulative sum of ID first word, second word, last word data, used for ID verification  The ID number can be used with the download tool to encrypt the target program. For general applications, just use the first 32 digits of the ID number.\n"});index.add({'id':6,'href':'/docs/7-pm_sleep_reset/','title':"7. Power management",'content':"7. Power management, sleep and reset 7.1 External power input The CH559 chip has an internal working voltage of 3.3V, and the input/output voltage of the I/O pin is 3.3V. The I/O pins except P1.0~P1.7, XI, XO, and RST can withstand 5V voltage input. The CH559 chip has a 5V to 3.3V low dropout voltage regulator that supports an external 3.3V or 5V supply voltage input. The two supply voltage input modes refer to the table below.\n  External supply voltageVIN5 pin voltage: external voltage 3.3V~5VVDD33 pin voltage: internal voltage 3.3V  3.3V includes less than 3.6VInput external 3.3V voltage to voltage regulator, must be grounded to not less than 0.1uF decoupling capacitorInput external 3.3V as internal working power supply, must be grounded to ground not less than 0.1uF decoupling capacitor 5V includes greater than 3.6VInput external 5V voltage to voltage regulator, must be grounded to not less than 0.1uF decoupling capacitorInternal voltage regulator 3.3V output and 3.3V internal working power input, must be grounded to not less than 3.3uF decoupling capacitor  After the power is turned on or the system is reset, the CH559 is running by default. When some function modules are not needed, the clocks of these modules can be turned off to reduce power consumption. When the CH559 does not need to run at all, the PD in the PCON can be set to sleep. In the sleep state, external wake-up can be selected via USB, UART0, UART1, SPI0 and some GPIOs.\n7.2 Power and Sleep Control Registers  Table 7.2.1 List of Power and Sleep Control Registers\n   NameAddressDescriptionReset value  WDOG_COUNTFFhWatchdog Count Register00h RESET_KEEPFEhreset holding register00h WAKE_CTRLEBhSleep Wake Control Register00h SLEEP_CTRLEAhSleep control register00h PCON87hPower Control Register10h  Watchdog Count Register (WDOG_COUNT):   BitNameAccessDescriptionReset value  [7:0]WDOG_COUNTRWThe current count of the watchdog is 0FFh. It overflows when it is 00h. When it overflows, it automatically sets the interrupt flag bWDOG_IF_TO to 100h  Reset holding register (RESET_KEEP):   BitNameAccessDescriptionReset value  [7:0]RESET_KEEPRWReset the holding register, the value can be modified manually, except for the power-on reset to clear it, any other reset does not affect the value00h  Sleep wake control register (WAKE_CTRL), which can be written only in safe mode:   BitNameAccessDescriptionReset value  7bWAK_BY_USBRWUSB event wake-up enable, this bit is 0, no wake-up is allowed0 6bWAK_RXD1_LORWUART1 receives an input low wake-up enable. This bit is 0 to disable wake-up.\nSelect XA/XB differential input in iRS485 mode, select RXD1 or RXD1_ pin according to bIER_PIN_MOD1=1/0 in non-iRS485 mode0 5bWAK_P1_5_LORWP1.5 low wake enable, 0 disable wakeup0 4bWAK_P1_4_LORWP1.4 Low wake enable, 0 disable wakeup0 3bWAK_P0_3_LORWP0.3 Low wake enable, 0 disable wakeup0 2bWAK_CAP3_LORWTimer3 captures the input low wake enable, and 0 disables wakeup.\nSelect CAP3 or CAP3_ pin according to bTMR3_PIN_X=0/10 1bWAK_P3_2E_3LRWP3.2 Edge change and P3.3 low wake enable, 0 disable wakeup0 0bWAK_RXD0_LORWUART0 receives input low wake enable, 0 disables wakeup.\nSelect RXD0 or RXD0_ pin according to bUART0_PIN_X=0/10  Sleep Control Register (SLEEP_CTRL), which can be written only in Safe Mode:   BitNameAccessDescriptionReset value  7bSLP_OFF_USBRWUSB clock off control, this bit is 1 Off clock0 6bSLP_OFF_ADCRWADC clock off control, this bit is 1 Off clock0 5bSLP_OFF_UART1RWUAR1 clock off control, this bit is 1 off clock0 4bSLP_OFF_P1S1RWPWM1 and SPI1 clock off control, this bit is 1 OFF clock0 3bSLP_OFF_SPI0RWSPI0 clock off control, this bit is 1 off clock0 2bSLP_OFF_TMR3RWTimer3 clock off control, this bit is 1 off clock0 1bSLP_OFF_LEDRWLED-CTRL Clock off control, this bit is 1 Off clock0 0bSLP_OFF_XRAMRWxRAM clock off control, this bit is 1 off clock0  Power Control Register (PCON):   BitNameAccessDescriptionReset value  7SMODRWWhen using Timer 1 to generate UART0 baud rate, select the communication baud rate of UART0 mode 1, 2, 3: 0-slow mode; 1-fast mode0 6reservedROreserved0 5bRST_FLAG1R0chip last reset flag high0 4bRST_FLAG0R0chip last reset flag low1 3GF1RWuniversal flag 1: User can define it by itself, can be cleared or set by software.0 2GF0RWgeneral flag 0: user can define it himself, can be cleared or set by software0 1PDRWsleep mode enable, set to sleep after 1 wake-up hardware automatically cleared0 0reservedR0reserved0   Table 7.2.2 Description of the chip's last reset flag\n   bRST_FLAG1bRST_FLAG0Reset flag description  00Software reset, source: bSW_RESET=1 and (bBOOT_LOAD=0 or bWDOG_EN=1) 01Power-on reset, source: VDD33 pin voltage is lower than detection level 10Watchdog reset, source: bWDOG_EN=1 and watchdog timeout 11External pin is manually reset, source: En_P5.7_RESET=1 and P5.7 input high  7.3 Reset Control The CH559 has four reset sources: power-on reset, external reset, software reset, watchdog reset, and the latter three are hot resets.\n7.3.1 Power-on reset Power-on reset POR is generated by the on-chip voltage detection circuit. The POR circuit continuously monitors the supply voltage of the VDD33 pin. Below the detection level, Vpot generates a power-on reset, and the hardware automatically delays Tpor to maintain the reset state. After the delay expires, CH559 runs. Only the power-on reset causes the CH559 to reload the configuration information and clear RESET_KEEP. Other thermal resets do not affect.\n7.3.2 External reset An external reset is generated by a high level applied to the RST pin. The reset process is triggered when the configuration information En_P5.7_RESET is 1 and the high level on the RST pin lasts longer than Trst. When the external high level signal is cancelled, the hardware automatically delays Trdl to maintain the reset state. After the delay expires, CH559 starts from the 0 address.\n7.3.3 Software Reset The CH559 supports an internal software reset to actively reset the CPU state and re-run without external intervention. Set bSW_RESET in the global configuration register GLOBAL_CFG to 1, software reset, and automatically delay Trdl to maintain the reset state. After the delay expires, CH559 starts from 0 address, and bSW_RESET bit is automatically cleared by hardware.\nWhen bSW_RESET is set, if bBOOT_LOAD=0 or bWDOG_EN=1, bRST_FLAG1/0 will be indicated as a software reset after reset; when bSW_RESET is set to 1, if bBOOT_LOAD=1 and bWDOG_EN=0, then bRST_FLAG1/0 will not generate new The reset flag, but keeps the previous reset flag unchanged.\nFor a chip with an ISP boot program, after the power-on reset, run the boot program, which resets the chip to the application state according to the software reset. This software reset only causes bBOOT_LOAD to be cleared, and does not affect the state of bRST_FLAG1/0. (Because bBOOT_LOAD=1 before reset), when switching to the application state, bRST_FLAG1/0 still indicates the power-on reset state.\n7.3.4 Watchdog Reset The watchdog reset is generated when the watchdog timer times out. The watchdog timer is an 8-bit counter that counts the clock frequency of the system\u0026rsquo;s main frequency, Fsys/262144. When the 0FFh is turned to 00h, an overflow signal is generated.\nThe watchdog timer overflow signal will trigger the interrupt flag bWDOG_IF_TO to be 1, which is automatically cleared when the WDOG_COUNT is reloaded or when the corresponding interrupt service routine is entered.\nDifferent timing periods Twdc are achieved by writing different count initial values to WDOG_COUNT. At 12MHz, the watchdog timing period Twdc at 00h is about 5.9 seconds and about 2.8 seconds at 80h.\nIf bWDOG_EN = 1 when the watchdog timer overflows, a watchdog reset is generated, and Trdl is automatically delayed to maintain the reset state. After the delay is over, CH559 starts from the 0 address.\nTo avoid being reset by the watchdog when bWDOG_EN=1, WDOG_COUNT must be reset in time to avoid overflow.\n"});index.add({'id':7,'href':'/docs/8-system_clock/','title':"8. System Clock",'content':"8. System Clock 8.1 Clock Block Diagram  Figure 8.1.1 Clock system and structure\n The internal clock or external clock is selected as the original clock Fosc, and then the PLL is multiplied to generate the Fpll high-frequency clock. Finally, two sets of frequency converters are used to obtain the system clock Fsys and the clock of the USB module Fusb4x.\nThe system clock Fsys is provided to each module of the CH559 directly or after clock gating. Each module does not need to work at the same time. In order to reduce power consumption, the clock of modules that do not need to work can be disabled by setting the sleep control register.\n8.2 Register description  Table 8.2.1 Clock control register list\n   NameAddressDescriptionReset value  CLOCK_CFGB3hSystem clock configuration register98h PLL_CFGB2hPLL clock configuration registerD8h  System clock configuration register (CLOCK_CFG), writable only in safe mode:   BitNameAccessDescriptionReset value  7bOSC_EN_INTRWInternal clock oscillator enable, this bit is 1 to enable the internal clock oscillator and select the internal clock; this bit is 0 to disable the internal clock oscillator and select an external crystal oscillator1 6bOSC_EN_XTRWExternal crystal oscillator is enabled. If this bit is 1, the P4.6 / P4.7 pins are used as XI / XO and the oscillator is enabled. An external quartz crystal or ceramic oscillator is required between XI and XO; this bit is 0. Off External oscillator0 5bWDOG_IF_TOR0Watchdog timer interrupt flag bit. When this bit is 1, it indicates that there is an interrupt, which is triggered by the timer overflow signal. When this bit is 0, it indicates that there is no interrupt. This bit is automatically cleared when the watchdog count register WDOG_COUNT is reloaded or after entering the corresponding interrupt service routine0 [4:0]MASK_SYS_CK_DIVRWSystem clock division factor, when the value is 00000b, it means 100000b11000b  PLL clock configuration register (PLL_CFG), writable only in safe mode:   BitNameAccessDescriptionReset value  [7:5]MASK_USB_4X_DIVRWUSB clock division factor, when the value is 000b, it means 1000b110b [4:0]MASK_PLL_MULTRWPLL reference clock multiplier11000b  8.3 Clock configuration The CH559 chip uses the internal clock by default after power-on. The internal clock frequency is 12MHz. The internal clock or external crystal oscillator clock can be selected by CLOCK_CFG. If the external crystal oscillator is turned off, the XI and XO pins can be used as P4.6 and P4.7 ordinary I / O ports.\nIf an external crystal oscillator is used to provide the clock, then the crystal should be connected between the XI and XO pins, and the oscillating capacitor should be connected to the XI and XO pins respectively to GND; if the clock signal is input directly from the outside, Pin input, XO pin floating.\n Original clock frequency Fosc = bOSC_EN_INT? 12MHz: Fxt PLL frequency Fpll = Fosc * (PLL_CFG \u0026amp; MASK_PLL_MULT) USB clock division factor Kusb = (PLL_CFG \u0026amp; MASK_USB_4X_DIV) \u0026raquo; 5 USB clock frequency Fusb4x = Fpll / (Kusb? Kusb: 8) System clock division factor Ksys = CLOCK_CFG \u0026amp; MASK_SYS_CK_DIV System frequency Fsys = Fpll / (Ksys? Ksys: 32) After reset, Fosc = 12MHz, Fpll = 288MHz, Fusb4x = 48MHz, Fsys = 12MHz.  To switch to an external crystal oscillator to provide the clock:  Enter safe mode, step one SAFE_MOD = 55h; step two SAFE_MOD = AAh. Set \u0026ldquo;bOSC_EN_XT\u0026rdquo; in CLOCK_CFG by \u0026ldquo;bit-or\u0026rdquo; operation, other bits remain unchanged, enable crystal oscillator. Delay of several milliseconds, usually 5mS ~ 10mS, waiting for the crystal oscillator to work stably. Enter the safe mode again, step one SAFE_MOD = 55h; step two SAFE_MOD = AAh. Clear the bOSC_EN_INT in CLOCK_CFG to 0 with the \u0026ldquo;bit and\u0026rdquo; operation, the other bits remain unchanged, and switch to the external clock. Close the safe mode, and write any value to SAFE_MOD to terminate the safe mode in advance.  The steps to modify the system clock are as follows:  Calculate the new values of PLL_CFG and CLOCK_CFG in advance to avoid the calculation process too long beyond the validity period of the safe mode. Enter the safe mode, step one SAFE_MOD = 55h; step two SAFE_MOD = AAh. Write new value to PLL_CFG. Write a new value to CLOCK_CFG. Close the safe mode, and write any value to SAFE_MOD to terminate the safe mode in advance.  Remarks:  PLL frequency Fpll is recommended not to exceed the frequency range of 24MHz ~ 350MHz. Prioritize the use of a lower system clock frequency Fsys, thereby reducing system dynamic power consumption and widening the operating temperature range. If the USB module is used, Fusb4x must be adjusted to 48MHz. Switching the external crystal and modifying the main frequency of the system are two independent operations. If both are required at the same time, it is recommended to divide into two cases:  if the external crystal frequency does not exceed 13MHz, then switch to the external crystal first, and then modify the system main frequency. If the external crystal frequency is greater than 13MHz, first reduce the PLL reference clock multiplication factor in the PLL_CFG register to avoid the PLL frequency Fpll overflow, then switch to the external crystal, and finally modify the system main frequency, or you can also modify the PLL_CFG At the same time modify the system clock.    "});index.add({'id':8,'href':'/docs/9-interrupt/','title':"9. Interrupt",'content':"9. Interrupt The CH559 chip supports 14 sets of interrupt signal sources, including 6 sets of interrupts compatible with the standard MCS51: INT0, T0, INT1, T1, UART0, T2, and extended 8 sets of interrupts: SPI0, TMR3, USB, ADC, UART1, PWM1 GPIO, WDOG, among which GPIO interrupt can be selected from 7 I/O pins.\n9.1 Register description  Table 9.1.1 Interrupt vector table\n   Interrupt SourceEntry AddressInterrupt numberDescriptionDefault priority  INT_NO_INT00x00030External interrupt 0 or LED control card interrupt:\nWhen bLED_OUT_EN = 0 is external interrupt 0;\nWhen bLED_OUT_EN = 1 is LED control card interrupt\nHigh priority\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\n\u0026darr;\nLow priority INT_NO_TMR00x000B1Timer 0 interrupt INT_NO_INT10x00132External interrupt 1 INT_NO_TMR10x001B3Timer 1 interrupt INT_NO_UART00x00234UART0 interrupt INT_NO_TMR20x002B5Timer 2 interrupt INT_NO_SPI00x00336SPI0 interrupt INT_NO_TMR30x003B7Timer 3 interrupt INT_NO_USB0x00438USB interrupt INT_NO_ADC0x004B9ADC interrupt INT_NO_UART10x005310UART1 interrupt INT_NO_PWM10x005B11PWM1 interrupt INT_NO_GPIO0x006312GPIO interrupt INT_NO_WDOG0x006B13Watchdog timer interrupt   Table 9.1.2 Interrupt related register list\n   NameAddressDescriptionReset value  IP_EXE9hExtended interrupt priority control register00h IE_EXE8hExtended interrupt enable register00h GPIO_IECFhGPIO interrupt enable register00h IPB8hInterrupt Priority Control Register00h IEA8hinterrupt enable register00h  Interrupt Enable Register (IE):   BitNameAccessDescriptionReset value  7EARWGlobal interrupt enable control bit, this bit is 1 and E_DIS is 0 to enable interrupts. this bit is 0 to mask all interrupt requests0 6E_DISRWGlobal interrupt disable control bit, this bit is 1 to mask all interrupt requests. this bit is 0 and EA is 1 to enable interrupts. This bit is typically used to temporarily disable interrupts during flash-ROM operations0 5ET2RWTimer 2 interrupt enable bit, this bit is 1 to enable T2 interrupt. it is 0 to mask0 4ESRWAsynchronous serial port 0 interrupt enable bit, this bit is 1 to enable UART0 interrupt. masked to 00 3ET1RWTimer 1 interrupt enable bit. This bit is 1 to enable the T1 interrupt. it is masked to 0.0 2EX1RWExternal interrupt 1 enable bit, this bit is 1 to enable the INT1 interrupt. masked to 00 1ET0RWTimer 0 interrupt enable bit, this bit is 1 to enable the T0 interrupt. masked to 00 0EX0RWExternal interrupt 0 and LED control card interrupt enable bit, this bit is 1 to enable INT0 / LED interrupt, selected by bLED_OUT_EN. masked to 00  Extended interrupt enable register (IE_EX):   BitNameAccessDescriptionReset value  7IE_WDOGRWWatchdog timer interrupt enable bit, this bit is 1 to enable WDOG interrupt; 0 to mask0 6IE_GPIORWGPIO interrupt enable bit, this bit is 1 to enable interrupts enabled in GPIO_IE; 0 to mask all interrupts in GPIO_IE0 5IE_PWM1RWPWM1 interrupt enable bit. This bit is 1 to enable PWM1 interrupt; 0 to mask 00 4IE_UART1RWasynchronous serial port 1 interrupt enable bit, this bit is 1 to enable UART1 interrupt; 0 to mask0 3IE_ADCRWADC analog-to-digital conversion interrupt enable bit, this bit is 1 to enable ADC interrupt; 0 to mask0 2IE_USBRWUSB interrupt enable bit, this bit is 1 to enable USB interrupt; 0 to mask0 1IE_TMR3RWTimer 3 interrupt enable bit, this bit is 1 to enable Timer3 interrupt; 0 to mask0 0IE_SPI0RWSPI0 interrupt enable bit, this bit is 1 to enable SPI0 interrupt; 0 to mask0  GPIO interrupt enable register (GPIO_IE):   BitNameAccessDescriptionReset value  7bIE_IO_EDGERWGPIO edge interrupt mode enable:\n This bit is 0 to select the level interrupt mode.If the GPIO pin input valid level, bIO_INT_ACT is 1 and the interrupt is always requested.When the GPIO input invalid level, bIO_INT_ACT is 0 and the interrupt request is canceled.\n This bit is 1 to select the edge interrupt mode. When a valid edge is input to the GPIO pin, the interrupt flag bIO_INT_ACT is generated and an interrupt is requested. This interrupt flag cannot be cleared by software. It can only be reset or in level interrupt mode or enter the corresponding interrupt service routine Is automatically cleared\n0 6bIE_RXD1_LORWThis bit is 1 to enable UART1 receive pin interrupt (level mode is active low, edge mode falling edge is active). this bit is 0 to disable. Select XA/XB differential input in iRS485 mode, select RXD1 or RXD1_ pin according to bIER_PIN_MOD1 = 1/0 in non-iRS485 mode0 5bIE_P5_5_HIRWThis bit is 1 to enable the P5.5 interrupt (level mode is active high and edge mode is active on rising edge); this bit is 0 to disable0 4bIE_P1_4_LORWThis bit is 1 to enable the P1.4 interrupt (level mode is active low, edge mode is active on falling edge); this bit is 0 to disable0 3bIE_P0_3_LORWThis bit is 1 to enable the P0.3 interrupt (active in low level in level mode and valid in falling edge in edge mode); this bit is 0 to disable0 2bIE_P5_7_HIRWThis bit is 1 to enable the P5.7 interrupt (level mode is active high and edge mode is active on rising edge); this bit is 0 to disable0 1bIE_P4_1_LORWThis bit is 1 to enable the P4.1 interrupt (active in low level in level mode and valid in falling edge in edge mode); this bit is 0 to disable0 0bIE_RXD0_LORWThis bit is 1 to enable the UART0 receive pin interrupt (level mode is active low, edge mode is active falling edge); this bit is 0 to disable. Select RXD0 or RXD0_ pin according to bUART0_PIN_X = 0/10  Interrupt Priority Control Register (IP):   BitNameAccessDescriptionReset value  7PH_FLAGR0High priority interrupt executing flag0 6PL_FLAGR0Low Priority Interrupt Execution Flag0 5PT2RWTimer 2 interrupt priority control bit0 4PSRWUART0 interrupt priority control bit0 3PT1RWTimer 1 interrupt priority control bit0 2PX1RWInterrupt priority control bit for external interrupt 10 1PT0RWtimer 0 interrupt priority control bit0 0PX0RWExternal Interrupt 0 and Interrupt Priority Control Bit for LED Control Card Interrupt0  Extended interrupt priority control register (IP_EX):   BitNameAccessDescriptionReset value  7bIP_LEVELR0Current interrupt nesting level flag bit. If this bit is 0, it means no interrupt or nested level 2 interrupt.If this bit is 1, it means current nested level 1 interrupt.0 6bIP_GPIORWGPIO interrupt priority control bit0 5bIP_PWM1RWPWM1 interrupt priority control bit0 4bIP_UART1RWUART1 interrupt priority control bit0 3bIP_ADCRWADC interrupt priority control bit0 2bIP_USBRWUSB interrupt priority control bit0 1bIP_TMR3RWTimer3 interrupt priority control bit0 0bIP_SPI0RWSPI0 interrupt priority control bit0  The IP and IP_EX registers are used to set the interrupt priority. If a bit is set to 1, the corresponding interrupt source is set to a high priority. If a bit is cleared to 0, the corresponding interrupt source is set to a low priority . For the same level interrupt source, the system has a default priority order. The default priority order is shown in Table 9.1.1. Its PH_FLAG and PL_FLAG combination indicates the priority of the current interrupt.\n Table 9.1.3 Current interrupt priority status indication\n   PH_FLAGPL_FLAGCurrent interrupt priority status  00No interruption currently 01Low priority interrupt is currently executing 10High priority interrupt is currently executing 11Unexpected state, unknown error "});index.add({'id':9,'href':'/docs/10-gpio/','title':"10. I/O Port",'content':"10. I/O Port 10.1 Introduction to GPIO CH559 provides up to 45 I / O pins, some pins have alternate functions. Among them, the input and output of ports P0 ~ P3 and the output of P4 can be bit-addressed.\nIf the pin is not configured as an alternate function, the default is the general-purpose I/O pin state. When used as a general-purpose digital I/O, all I/O ports have a true “read-modify-write” function, which supports bit manipulation instructions such as SETB or CLR to independently change the direction of certain pins or port levels.\n10.2 GPIO Register All registers and bits in this section are expressed in a common format: the lowercase \u0026ldquo;n\u0026rdquo; represents the serial number of the port (n = 0, 1, 2, 3), and the lowercase \u0026ldquo;x\u0026rdquo; represents the serial number of the bit (x = 0, 1, 2, 3, 4, 5, 6, 7).\n Table 10.2.1 GPIO Register List\n   NameAddressDescriptionReset value  P080hP0 port input and output registerFFh P0_DIRC4hP0 port direction control register00h P0_PUC5hPort 0 pull-up enable register00h/FFh P190hP1 port input and output registerFFh P1_IEB9hP1 port input enable registerFFh P1_DIRBAhP1 port direction control register00h P1_PUBBhP1 port pull-up enable registerFFh P2A0hP2 port input and output registerFFh P2_DIRBChP2 port direction control register00h P2_PUBDhP2 port pull-up enable registerFFh P3B0hP3 port input and output registerFFh P3_DIRBEhP3 port direction control register00h P3_PUBFhP3 port pull-up enable registerFFh P4_OUTC0hP4 port output register00h P4_INC1hP4 port input register (read only)FFh P4_DIRC2hP4 port direction control register00h P4_PUC3hP4 port pull-up enable registerFFh P4_CFGC7hP4 port configuration register00h P5_INC7hP5 port input register (read only)00h PIN_FUNCCEhPin Function Select Register00h PORT_CFGC6hPort Configuration Register0Fh XBUS_SPEEDFDhBus speed configuration registerFFh XBUS_AUXA2hBus auxiliary setting register00h  Port configuration register (PORT_CFG):   BitNameAccessDescriptionReset value  [7:4]bPn_DRVRWPn port output drive capability selection, this bit is 0 to select the drive current 5mA level. This bit is 1 for P0 / P2 / P3 to select the drive current 20mA level, and for P1 to select the drive current 10mA level0000b [3:0]bPn_OCRWPn port open-drain output enable, this bit is 0 to set the port as push-pull output. This bit is 1 to set the port to be open-drain output1111b  Pn port input and output register (Pn):   BitNameAccessDescriptionReset value  [7:0]Pn.0~Pn.7RWPn.x pin status input and data output bits, bit-addressableFFh  Pn port direction control register (Pn_DIR):   BitNameAccessDescriptionReset value  [7:0]Pn_DIRRWPn.x pin direction setting00h  P0 port pull-up enable register (P0_PU) and Pn port pull-up enable register (Pn_PU), where n = 1/2/3:   BitNameAccessDescriptionReset value  [7:0]P0_PURWP0.x pin pull-up resistor is enabled (when En_P0_Pullup = 0 is configured)00h P0.x pin pull-up resistor is enabled (when En_P0_Pullup = 1 is configured)FFh [7:0]Pn_PURWPn.x pin pull-up resistor is enabled, this bit is 0 to disable pull-up; this bit is 1 to enable pull-upFFh  The configuration of the Pn port is implemented by the combination of the bit bPn_OC in the PORT_CFG, the port direction control register Pn_DIR, and the port pull-up enable register Pn_PU, as follows.\n Table 10.2.2 Port configuration register combinations\n   bPn_OCPn_DIRPn_PUDescription  000High-impedance input mode, no pull-up resistor on pin 001Pull-up input mode, pins have pull-up resistors 01xPush-pull output mode, with symmetrical driving ability, can output or absorb large current 100High-impedance input weak quasi-bidirectional mode, open-drain output, no pull-up resistor on pin 110High-impedance input quasi-bidirectional mode, open-drain output, no pull-up resistor on the pin, when the output changes from low to high, it automatically drives high for 2 clock cycles to speed up the conversion 101Weak quasi-bidirectional mode (imitation of 8051), open-drain output, support input, pin with pull-up resistor 111Quasi-bidirectional mode (standard 8051), open-drain output, support input, pins have pull-up resistors, when the output changes from low to high, it automatically drives high for 2 clock cycles to speed up the conversion  Ports P0~P3 support pure input or push-pull output and quasi-bidirectional modes. Port P4 supports pure input or push-pull output and other modes. Each pin has a freely controllable internal pull-up resistor connected to VDD33, and a protection diode connected to GND.\nFigure 10.2.1 is the equivalent schematic of the P1.x pin of the P1 port. After removing P1_IE and AIN and ADC_CHANN, it can be applied to the P0, P2, and P3 ports.\n Figure 10.2.1 I/O pin equivalent schematic\n P1 port input enable register (P1_IE):   BitNameAccessDescriptionReset value  [7:0]P1_IERWP1.x pin input enable, if this bit is 0, the pin is used for ADC analog input, digital input is disabled. If this bit is 1, the digital input is enabledFFh  10.3 P4 port P4 port output register (P4_OUT):   BitNameAccessDescriptionReset value  [7:0]P4_OUT.0~P4_OUT.7RWP4.x pin data output bit, bit-addressable00h  P4 port input register (P4_IN):   BitNameAccessDescriptionReset value  [7:0]P4_INR0P4.x pin status input bitFFh  P4 port pull-up enable register (P4_PU):   BitNameAccessDescriptionReset value  [7:0]P4_PURWP4.x pin pull-up resistor is enabled, this bit is 0 to disable pull-up; this bit is 1 to enable pull-upFFh  P4 port direction control register (P4_DIR):   BitNameAccessDescriptionReset value  [7:0]P4_DIRRWP4.x pin direction setting, this bit is 0 for input; this bit is 1 for output00h  P4 port configuration register (P4_CFG) and P5 port input register (P5_IN):   BitNameAccessDescriptionReset value  7P5.7R0P5.7 pin status input bit0 6bIO_INT_ACTR0GPIO interrupt request activation status:\nWhen bIE_IO_EDGE = 0, this bit is 1 to indicate the GPIO input active level, interrupt will be requested, and 0 to indicate the input invalid level.\nWhen bIE_IO_EDGE = 1, this bit is used as an edge interrupt flag. A value of 1 indicates that a valid edge was detected.This bit cannot be cleared by software. It can only be automatically cleared during reset or level interrupt mode or when entering the corresponding interrupt service routine zero\n0 5P5.5R0P5.5 pin status input bit with built-in controllable pull-down resistor0 4P5.4R0P5.4 pin status input bit with built-in controllable pull-down resistor0 3bSPI0_PIN_XRWSPI0 pin SCS / SCK mapping enable. If this bit is 0, P1.4 / P1.7 is used. If this bit is 1, P4.6 / P4.7 is used0 2bP4_DRVRWP4 port output drive capability selection, this bit is 0 to select the drive current 5mA level. This bit is 1 to select the drive current 20mA level0 1P5.1R0P5.1 pin status input bit with built-in controllable pull-down resistor0 0P5.0R0P5.0 pin status input bit with built-in controllable pull-down resistor0  10.4 GPIO Multiplexing and Mapping Some of the I / O pins of CH559 have alternate functions. After power-on, they are all general-purpose I / O pins. After different function modules are enabled, the corresponding pins are configured as the corresponding function pins of the respective function modules.\nPin function selection register (PIN_FUNC):   BitNameAccessDescriptionReset value  7bPWM1_PIN_XRWPWM1/PWM2 pin mapping enable bit, if this bit is 0, PWM1/2 uses P2.4/P2.5. If this bit is 1, PWM1/2 uses P4.3/P4.50 6bTMR3_PIN_XRWPWM3/CAP3 pin mapping enable bit. When this bit is 0, PWM3/CAP3 uses P1.2. When this bit is 1, PWM3/CAP3 uses P4.20 5bT2EX_PIN_XRWT2EX/CAP2 pin mapping enable bit. When this bit is 0, T2EX/CAP2 uses P1.1. When this bit is 1, T2EX/CAP2 uses P2.50 4bUART0_PIN_XRWUART0 pin mapping enable bit. When this bit is 0, RXD0/TXD0 uses P3.0/P3.1. When this bit is 1, RXD0/TXD0 uses P0.2/P0.3.0 3bXBUS_ENRWxBUS external bus function enable bit, this bit is 0 to disable the external bus; this bit is 1 to enable the P0 port as an 8-bit data bus, and P3.6/P3.7 as write/read strobe control during bus access0 2bXBUS_CS_OERWxBUS external bus chip select output enable bit. This bit is 0 to disable the output of chip select and can be decoded by external circuits. P3.4 is set as CS0 when this bit is 1 (XCS0 chip select 0, active low), and When ALE is disabled, the bus address A15 is inverted and output to P3.3 (equivalent to chip select 1, active low)0 1bXBUS_AH_OERWxBUS External bus high 8-bit address output enable bit, this bit is 0 to disable output. When this bit is 1, during the MOVX_@DPTR instruction access to the external bus, the P2 port output bus address is the upper 8 bits0 0bXBUS_AL_OERWThe lower 8-bit address output enable bit of the xBUS external bus. When this bit is 0, it is a multiplexed address mode. When accessing the external bus, the lower 8 bits of the address are multiplexed with the data bus as required, and the external circuit is controlled by ALE to latch. If this bit is 1, it is the direct address mode.The lower 8-bit addresses A0~A7 are output through P4.0~P4.5 and P3.5 and P2.7.0   Figure 10.2.1 I/O pin equivalent schematic\n   GPIOOther functions: in order of priority from left to right  P0[0] AD0, UDTR/bUDTR, P0.0 P0[1] AD1, URTS/bURTS, P0.1 P0[2] AD2, RXD_/bRXD_, P0.2 P0[3] AD3, TXD_/bTXD_, P0.3 P0[4] AD4, UCTS/bUCTS, P0.4 P0[5] AD5, UDSR/bUDSR, P0.5 P0[6] AD6, URI/bURI, P0.6 P0[7] AD7, UDCD/bUDCD, P0.7 P1[0] AIN0, T2/bT2, CAP1/bCAP1, P1.0 P1[1] AIN1, T2EX/bT2EX, CAP2/bCAP2, P1.1 P1[2] AIN2, PWM3/bPWM3, CAP3/bCAP3, P1.2 P1[3] AIN3, P1.3 P1[4] AIN4, SCS/bSCS, P1.4 P1[5] AIN5, MOSI/bMOSI, P1.5 P1[6] AIN6, MISO/bMISO, P1.6 P1[7] AIN7, SCK/bSCK, P1.7 P2[0] A8, P2.0 P2[1] MOSI1/bMOSI1, A9, P2.1 P2[2] MISO1/bMISO1, A10, P2.2 P2[3] SCK1/bSCK1, A11, P2.3 P2[4] PWM1/bPWM1, A12, P2.4 P2[5] TNOW/bTNOW, PWM2/bPWM2, A13, T2EX_/bT2EX_, CAP2_/bCAP2_, P2.5 P2[6] RXD1/bRXD1, A14, P2.6 P2[7] TXD1/bTXD1, DA7/bDA7, A15, P2.7 P3[0] RXD/bRXD, P3.0 P3[1] TXD/bTXD, P3.1 P3[2] LED0/bLED0, INT0/bINT0, P3.2 P3[3] LED1/bLED1, !A15, INT1/bINT1, P3.3 P3[4] LEDC/bLEDC, XCS0/bXCS0, T0/bT0, P3.4 P3[5] DA6/bDA6, T1/bT1, P3.5 P3[6] WR/bWR, P3.6 P3[7] RD/bRD, P3.7 P4[0] LED2/bLED2, A0, RXD1_/bRXD1_, P4.0 P4[1] A1, P4.1 P4[2] PWM3_/bPWM3_, CAP3_/bCAP3_, A2, P4.2 P4[3] PWM1_/bPWM1_, A3, P4.3 P4[4] LED3/bLED3, TNOW_/bTNOW_, TXD1_/bTXD1_, A4, P4.4 P4[5] PWM2_/bPWM2_, A5, P4.5 P4[6] XI, SCS_/bSCS_, P4.6 P4[7] XO, SCK_/bSCK_, P4.7 P5[0] DM/bDM, P5.0 P5[1] DP/bDP, P5.1 P5[4] HM/bHM, ALE, XB, P5.4 P5[5] HP/bHP, !A15, XA, P5.5 P5[7] RST/bRST, P5.7  The priority order from left to right described in the above table refers to the priority order when multiple functional modules compete to use the GPIO. For example, the P2 port has been set to the upper 8 bits of the output bus address. If only the A8~A11 addresses are actually used, then P2.4/P2.5 can still be used for higher priority PWM1/PWM2 functions, P2.6 It can still be used for RXD1 function, P2.7 can still be used for higher priority TXD1 or DA7 functions, so as to avoid wasting P2.4~P2.7 pins when A12~A15 address is not used.\n"});index.add({'id':10,'href':'/docs/11-xbus/','title':"11. External bus xBUS",'content':"11. External bus xBUS 11.1 External bus registers External bus auxiliary setting register (XBUS_AUX):   BitNameAccessDescriptionReset value  7bUART0_TXR0Indicate the transmission status of UART0, 1 means it is transmitting0 6bUART0_RXR0Indicate the receiving status of UART0, 1 means it is receiving0 5bSAFE_MOD_ACTR0Indicate the safe mode status, 1 means that it is currently in safe mode0 4bALE_CLK_ENRWALE pin clock output enable, this bit is 1 to allow ALE to output the system's main frequency of 12 when there is no xBUS operation, that is, Fsys / 12; this bit is 0 to disable the output of clock signals and only output when necessary to access the external bus Low 8-bit address latch signal to reduce EMI0 3GF2RWGeneral flag bit 2: user can define by himself, can be cleared or set by software0 2bDPTR_AUTO_INCRWEnable auto-increment DPTR by 1 after the MOVX_@DPTR instruction is completed0 1reservedR0reserved0 0DPSRWDual DPTR data pointer selection bits:\nThis bit is 0 to select DPTR0. This bit is 1 to select DPTR10  External bus speed configuration register (XBUS_SPEED):   BitNameAccessDescriptionReset value  7bXBUS1_SETUPRWSelect XBUS1 settling time: if this bit is 0, then 2 clock cycles. If this bit is 1, then 3 clock cycles1 6bXBUS1_HOLDRWSelect XBUS1 hold time: if this bit is 0, it will take 1 clock cycle. If this bit is 1, it will take 2 clock cycles1 5bXBUS1_WIDTH1RWXBUS1 bus pulse width high1 4bXBUS1_WIDTH0RWXBUS1 bus pulse width low bit1 3bXBUS0_SETUPRWSelect XBUS0 settling time: If this bit is 0, it will take 2 clock cycles. If this bit is 1, it will take 3 clock cycles1 2bXBUS0_HOLDRWSelect XBUS0 hold time: if this bit is 0, it will take 1 clock cycle. If this bit is 1, it will take 2 clock cycles1 1bXBUS0_WIDTH1RWXBUS0 bus pulse width high order1 0bXBUS0_WIDTH0RWXBUS0 bus pulse width low bit1  11.2 External bus pins  Table 11.2.1 External bus pin list\n   GPIODirect Address Mode PinMultiplexed Address Mode PinDescription  P3.7RDRDExternal bus read signal output pin, active low, rising edge sampling input P3.6WRWRExternal bus write signal output pin, active low P0.0~P0.7D0~D7D0~D78-bit bidirectional data bus A0~A7Multiplex lower 8-bit address A [0:7] output, latched by external circuit controlled by ALE P4.0~P4.5A0~A5UnusedDirect bus address A [0: 5] output pin, P4_DIR output must be set P3.5A6UnusedBus direct address A6 output pin P2.7A7Bus direct address A7 output pin A15Bus address A15 output pin P2.0~P2.6A8~A14A8~A14Bus address A [8:14] output pin P3.4XCS0XCS0Chip select 0 output pin, address range 4000h~7FFFh, active low P3.3!A15!A15Bus address A15 inverting output pin, equivalent to chip select 1 output, address range 8000h~FFFFh, active low, only available in ALE disabled state P5.5!A15!A15Bus address A15 inverting output pin, equivalent to chip select 1 output, address range 8000h~FFFFh, active low, available only in ALE enabled state P5.4ALEMultiplexed low 8-bit address latch control output pin, active high ALESystem frequency 12-division clock Fsys / 12 output pin, duty cycle 1/12  Some of the above unused pins such as address output and chip select output in the external bus state can be used for other modules according to the GPIO multiplexing priority order, and the unused pins in P4.0~P4.5 can also be used. Set P4_DIR to keep the input status.\nWhen bXBUS_CS_OE = 1, the inverting signal of bus address A15 will select the output pin according to the ALE output status. When ALE is allowed to output, !A15 chooses to output from P5.5. When ALE is disabled to output, !A15 chooses from P3.3 output. The ALE output status is determined by the combination of bUH1_DISABLE, bXBUS_EN, bXBUS_AL_OE, and bALE_CLK_EN, refer to Table 11.2.2 below.\n Table 11.2.2 P5.4 Pin Multiplexing ALE Output Status Table\n   bUH1_DISABLEbXBUS_ENbXBUS_AL_OEbALE_CLK_ENP5.4 pin function description  0xxxDisable ALE output, priority as HM (P5.5 as HP) 10x0Disable ALE output, used as XB by default (P5.5 as XA) 10x1ALE only outputs the system's 12th-frequency clock signal 1110Disable ALE output, default for XB (P5.5 is used as XA) 1111ALE only outputs the system's 12th-frequency clock signal 1100ALE outputs the lower 8-bit address latch signal only on the bus 1101ALE outputs the lower 8-bit address latch signal when accessing the bus, and outputs the system's main frequency 12-frequency clock signal when idle "});index.add({'id':11,'href':'/docs/12-timer/','title':"12. Timer",'content':"12. Timer 12.1 Timer 0/1 Timer0 / 1 are two 16-bit timer / counters. TCON and TMOD are used to configure Timer0 and Timer1. TCON is used for timer / counter T0 and T1 start control and overflow interrupt and external interrupt control. Each timer is a 16-bit timing unit consisting of two 8-bit registers. The high byte counter of timer 0 is TH0, the low byte is TL0; the high byte counter of timer 1 is TH1, and the low byte is TL1. Timer 1 can also be used as a baud rate generator for UART0.\n Table 12.1.1 List of Timer 0/1 related registers\n   NameAddressDescriptionReset value  TH1 8Dh Timer1 count high byte xxh TH0 8Ch Timer0 count high byte xxh TL1 8Bh Timer1 count low byte xxh TL0 8Ah Timer0 count low byte xxh TMOD 89h Timer0 / 1 mode register 00h TCON 88h Timer0 / 1 control register 00h  Timer/Counter 0/1 Control Register (TCON):   BitNameAccessDescriptionReset value  7 TF1 RW Timer1 overflow interrupt flag bit, it is automatically cleared after entering Timer 1 interrupt 0 6 TR1 RW Timer1 start / stop bit, set to 1 to start, set or cleared by software 0 5 TF0 RW Timer0 overflow interrupt flag bit, enters timer 0 and is automatically cleared after interrupt 0 4 TR0 RW Timer0 start / stop bit, set to 1 to start, set or cleared by software 0 3 IE1 RW INT1 Interrupt request flag bit for external interrupt 1; it is automatically cleared after entering interrupt 0 2 IT1 RW INT1 External interrupt 1 trigger mode control bit. This bit is 0 to select the external interrupt to trigger at low level. This bit is 1 to select the external interrupt to trigger at falling edge. 0 1 IE0 RW INT0 Interrupt request flag for external interrupt 0. It is automatically cleared after entering interrupt 0 0 IT0 RW INT0 External interrupt 0 trigger mode control bit. This bit is 0 to select the external interrupt to trigger at low level. This bit is 1 to select the external interrupt to trigger at falling edge. 0  Timer/Counter 0/1 Mode Register (TMOD):   BitNameAccessDescriptionReset value  7 bT1_GATE RW The gate enable bit controls whether Timer1 start is affected by external interrupt signal INT1. If this bit is 0, whether Timer/Counter 1 is started has nothing to do with INT1. If this bit is 1, it can be started only when INT1 pin is high and TR1 is 1 0 6 bT1_CT RW Timing or counting mode selection bit, this bit is 0 to work in timing mode. This bit is 1 to work in counting mode, using the falling edge of T1 pin as clock 0 5 bT1_M1 RW Timer/Counter 1 mode selection high 0 4 bT1_M0 RW Timer/Counter 1 mode selection low 0 3 bT0_GATERW  Gating enable bit, controls whether Timer0 start is affected by external interrupt signal INT0. If this bit is 0, the timer/counter 0 is started regardless of INT0. If this bit is 1, only the INT0 pin is high and TR0 can be started 0 2 bT0_CT RW Timing or counting mode selection bit, this bit is 0 to work in timing mode; this bit is 1 to work in counting mode, using the falling edge of T0 pin as clock 0 1 bT0_M1 RW Timer/Counter 0 Mode selection high 0 0 bT0_M0 RW Timer/Counter 0 Mode selection low 0   Table 12.1.2 bTn_M1 and bTn_M0 select Timern operating mode (n = 0, 1)\n   bTn_M1bTn_M0Timern working mode (n = 0, 1)  0 0 Mode 0: 13-bit timer / counter n. The counting unit consists of the lower 5 bits of TLn and THn. The upper 3 bits of TLn are invalid. When the count changes from all 13 bits to all 0s, the overflow flag TFn is set and the initial value needs to be reset 0 1 Mode 1: 16-bit timer / counter n. The counting unit consists of TLn and THn. When the count changes from all 16 bits to all 0s, the overflow flag TFn is set and the initial value needs to be reset 1 0 mode 2: 8-bit reload timer / counter n, the counting unit uses TLn, THn as the reload counting unit. When the count changes from all 8 bits to all 0s, the overflow flag TFn is set and the initial value is automatically loaded from THn 1 1 Mode 3: If it is timer / counter 0, then timer / counter 0 is divided into two parts TL0 and TH0, TL0 is used as an 8-bit timer / counter and occupies all control bits of Timer0; and TH0 also serves as another 8-bit timer Use, occupy TR1, TF1 and interrupt resources of Timer1, and Timer1 is still available at this time, but the start control bit TR1 and overflow flag bit TF1 cannot be used. In the case of Timer / Counter 1, entering Mode 3 will stop Timer / Counter 1.  Timern count low byte (TLn) (n = 0, 1):   BitNameAccessDescriptionReset value  [7:0]TLnRWTimern count low bytexxh  Timern count high byte (THn) (n = 0, 1):   BitNameAccessDescriptionReset value  [7:0]TLnRWTimern count high bytexxh  12.2 Timer2 Timer2 is a 16-bit auto-reload timer/counter. It is configured through the T2CON and T2MOD registers. The high byte counter of timer 2 is TH2 and the low byte is TL2. Timer2 can be used as the baud rate generator of UART0. It also has two signal level capture functions. The capture count is stored in RCAP2 and T2CAP1 registers.\n Table 12.2.1 List of Timer2 related registers\n   NameAddressDescriptionReset value  TH2 CDh Timer2 Counter High Byte 00h TL2 CCh Timer2 counter low byte 00h T2COUNT CCh TL2 and TH2 form 16-bit SFR 0000h T2CAP1H CDh Timer2 Capture 1 data high byte (read only) xxh T2CAP1L CCh Timer2 capture 1 data low byte (read only) xxh T2CAP1 CCh T2CAP1L and T2CAP1H form a 16-bit SFR xxxxh RCAP2H CBh Count Reload/Capture 2 Data Register High Byte 00h RCAP2L CAh Count Reload/Capture 2 Data Register Low Byte 00h RCAP2 CAh RCAP2L and RCAP2H form a 16-bit SFR 0000h T2MOD C9h Timer2 mode register 00h T2CON C8h Timer2 Control Register 00h  Timer/Counter 2 Control Register (T2CON):   BitNameAccessDescriptionReset value  7 TF2 RW When bT2_CAP1_EN = 0, it is the overflow interrupt flag of Timer2. When Timer2 counts from 16 bits are all 1 to all 0, setting the overflow flag to 1 requires software to clear it; when RCLK = 1 or TCLK When = 1, this bit will not be set to 1 0 7CAP1FRW When bT2_CAP1_EN = 1, it is Timer2 capture 1 interrupt flag, which is triggered by the valid edge of T2 and needs to be cleared by software 0 6EXF2 RW Timer2 external trigger flag. When EXEN2 = 1, it is set by T2EX valid edge trigger. Need to be cleared by software. 0 5RCLK RW UART0 receive clock selection, this bit is 0 to select the baud rate generated by Timer1 overflow pulse; this bit is 1 to select the baud rate generated by Timer2 overflow pulse 0 4TCLK RW UART0 transmit clock selection, this bit is 0 to select the baud rate generated by Timer1 overflow pulse; this bit is 1 to select the baud rate generated by Timer2 overflow pulse 0 3EXEN2RW T2EX trigger enable bit, this bit is 0 to ignore T2EX. This bit is 1 to enable triggering reload or capture on T2EX valid edge 0 2 TR2 RW Timer2 start / stop bit, set to 1 to start, set or cleared by software 0 1 C_T2RW Timer2 clock source selection bit, this bit is 0 to use the internal clock; this bit is 1 to use the edge count based on the falling edge of the T2 pin 0 0CP_RL2RW Timer2 function selection bit. If RCLK or TCLK is 1, this bit should be forced to 0. If this bit is 0, Timer2 is used as a timer / counter, and it can automatically reload the initial count value when the counter overflows or the T2EX level changes; this bit is 1 to enable the capture 2 function of Timer2 and capture the valid edge of T2EX 0  Timer/Counter 2 Mode Register (T2MOD):   BitNameAccessDescriptionReset value  7bTMR_CLKRWThe fast clock mode enable of the T0 / T1 / T2 timer of the fast clock has been selected. If this bit is 1, the system clock Fsys without frequency division is used as the count clock. If this bit is 0, the frequency division clock is used. This bit has no effect on the timer that selects the standard clock0 6bT2_CLKRWTimer2 internal clock frequency selection bit. This bit is 0 to select the standard clock. The timing / counting mode is Fsys / 12. UART0 clock mode is Fsys / 4. This bit is 1 to select the fast clock. = 0) or Fsys (bTMR_CLK = 1), the UART0 clock mode is Fsys / 2 (bTMR_CLK = 0) or Fsys (bTMR_CLK = 1)0 5bT1_CLKRWTimer1 internal clock frequency selection bit. This bit is 0 to select the standard clock Fsys / 12. For 1 to select the fast clock Fsys / 4 (bTMR_CLK = 0) or Fsys (bTMR_CLK = 1)0 4bT0_CLKRWTimer0 internal clock frequency selection bit. This bit is 0 for the standard clock Fsys / 12. For 1 it is the fast clock Fsys / 4 (bTMR_CLK = 0) or Fsys (bTMR_CLK = 1)0 3bT2_CAP_M1RWTimer2 capture mode highCapture mode selection:\nX0: from falling edge to falling edge\n01: From any edge to any edge, that is, the level changes\n11: from rising edge to rising edge\n0 2bT2_CAP_M0RWTimer2 capture mode low0 1T2OERWTimer2 clock output enable bit, this bit is 0 to disable the output. This bit is 1 to enable the T2 pin output clock, the frequency is half of the Timer2 overflow rate0 0bT2_CAP1_ENRWCapture 1 mode is enabled when RCLK = 0, TCLK = 0, CP_RL2 = 1, C_T2 = 0, T2OE = 0, this bit is 1 to enable capture 1 function to capture the valid edge of T2. This bit is 0 to disable capture 10  Count Reload / Capture 2 Data Register (RCAP2):   BitNameAccessDescriptionReset value  [7:0]RCAP2HRWHigh byte of reload value in timer / counter mode. High byte of timer captured by CAP2 in capture mode00h [7:0]RCAP2LRWLow byte of reload value in timer / counter mode. Low byte of timer captured by CAP2 in capture mode00h  Timer2 counter (T2COUNT), only valid when bT2_CAP1_EN = 0:   BitNameAccessDescriptionReset value  [7:0]TH2RWHigh byte of current counter00h [7:0]TL2RWLow byte of current counter00h  Timer2 capture 1 data (T2CAP1), only valid when bT2_CAP1_EN = 1:   BitNameAccessDescriptionReset value  [7:0]T2CAP1HRWHigh byte of timer captured by CAP1xxh [7:0]T2CAP1LRWLow byte of timer captured by CAP1xxh  12.3 Timer3  Table 12.3.1 List of Timer3 related registers\n   NameAddressDescriptionReset value  T3_FIFO_H AFh FIFO high byte of Timer3 xxh T3_FIFO_L AEh FIFO low byte of Timer3 xxh T3_FIFO AEh T3_FIFO_L and T3_FIFO_H form a 16-bit SFR xxxxh T3_DMA_AH ADh DMA current buffer address high byte 0xh T3_DMA_AL ACh DMA current buffer address low byte xxh T3_DMA ACh T3_DMA_AL and T3_DMA_AH form a 16-bit SFR 0xxxh T3_DMA_CN ABh DMA Remaining Count Register 00h T3_CTRL AAh Timer3 Control Register 02h T3_STAT A9h Timer3 status register 00h T3_END_H A7h Timer3 count end high byte xxh T3_END_L A6h Timer3 low end byte count xxh T3_END A6h T3_END_L and T3_END_H form a 16-bit SFR xxxxh T3_COUNT_H A5h Timer3 current count high byte (read only) 00h T3_COUNT_L A4h Timer3 current count low byte (read only) 00h T3_COUNT A4h T3_COUNT_L and T3_COUNT_H form a 16-bit SFR 0000h T3_CK_SE_H A5h Timer3 clock division setting high byte 00h T3_CK_SE_L A4h Timer3 clock division setting low byte 20h T3_CK_SE A4h T3_CK_SE_L and T3_CK_SE_H form a 16-bit SFR 0020h T3_SETUP A3h Timer3 setting register 04h  Timer3 setup register (T3_SETUP):   BitNameAccessDescriptionReset value  7bT3_IE_ENDRWThis bit is 1 to enable the capture mode count timeout interrupt or the PWM mode cycle end interrupt. This bit is 0 to disable the enable0 6bT3_IE_FIFO_OVRWThis bit is 1 to enable the FIFO overflow interrupt. This bit is 0 to disable the enable0 5bT3_IE_FIFO_REQRWThis bit is 1 to enable capture mode FIFO = 4 interrupt or PWM mode FIFO 0 4bT3_IE_ACTRWThis bit is 1 to enable the capture mode input signal to activate the interrupt or PWM mode data to trigger the interrupt; this bit is 1 to disable the enable0 3reserveR0reserve0 2bT3_CAP_INR0Input level of the current capture pin after noise filtering1 1bT3_CAP_CLKRWThis bit is 1 to enable input capture without minimum pulse width limitation.It is only valid when T3_CK_SE is 1.It is used to capture high speed signals.0 0bT3_EN_CK_SERWThis bit is 1 to enable access to the clock divider setting register; this bit is 0 to enable access to the current count register0  Timer3 current count (T3_COUNT), only valid when bT3_EN_CK_SE = 0:   BitNameAccessDescriptionReset value  [7:0]T3_COUNT_HROTimer3 current count high byte00h [7:0]T3_COUNT_LROTimer3 current count low byte00h  Timer3 clock division setting register (T3_CK_SE), only valid when bT3_EN_CK_SE = 1:   BitNameAccessDescriptionReset value  [7:0]T3_CK_SE_HRWTimer3 clock divider high byte, only the lower 4 bits are valid, the upper 4 bits are fixed to 000h [7:0]T3_CK_SE_LRWLow byte of Timer3 clock divider20h  Timer3 count end value register (T3_END):   BitNameAccessDescriptionReset value  [7:0]T3_END_HRWTimer3 count end high bytexxh [7:0]T3_END_LRWTimer3 count end low bytexxh  Timer3 status register (T3_STAT):   BitNameAccessDescriptionReset value  7bT3_IF_DMA_ENDRWDMA Complete Interrupt Flag. A 1 in this bit indicates an interrupt. A 0 in this bit indicates no interrupt. Cleared on write 1 or cleared on T3_DMA_CN0 6bT3_IF_FIFO_OVRWA 1 in this bit indicates a FIFO overflow interrupt. A 0 in this bit indicates no interrupt. Write 1 clear0 5bT3_IF_FIFO_REQRWWhen this bit is 1, it indicates that the FIFO data interrupt flag is requested. In capture mode, it is triggered by FIFO = 4, and in PWM mode, it is triggered by FIFO 0 4bT3_IF_ACTRWWhen bT3_IE_ACT = 1, this bit is 1 to indicate that the capture mode input signal activates the interrupt or the PWM mode data triggers the interrupt. This bit is 0 without interrupt. Cleared on write 1 or cleared when accessing FIFO0 4bT3_IF_ENDRWWhen bT3_IE_ACT = 0, this bit is 1 to indicate the capture mode count timeout interrupt or PWM mode cycle end interrupt. If this bit is 0, there is no interrupt. Write 1 clear0 [3:0]MASK_T3_FIFO_CNTR0Timer3's current FIFO count0000b  Timer3 control register (T3_CTRL):   BitNameAccessDescriptionReset value  7bT3_CAP_M1RWTimer3 capture edge mode high. PWM data repeat mode high0 6bT3_CAP_M0RWTimer3 capture edge mode low bit. PWM data repeat mode high bit0 5bT3_PWM_POLARRWPWM output polarity control bit in PWM mode. If this bit is 0, the default low level is valid, and the high level is valid.If this bit is 1, the default high level is active, and the low level is valid.0 5bT3_CAP_WIDTHRWIn capture mode, the minimum capture pulse width setting bit. If this bit is 0, at least 4 frequency division clock cycles are valid.0 4bT3_DMA_ENRWThis bit is 1 to enable Timer3's DMA and DMA interrupts. 0 to disable it0 3bT3_OUT_ENRWThis bit is 1 to enable the PWM output of Timer3. This bit is 0 to disable0 2bT3_CNT_ENRWThis bit is 1 to enable Timer3 counting. This bit is 0 to pause counting0 1bT3_CLR_ALLRWThis bit is 1 to clear the Timer3 count and FIFO, which needs to be cleared by software1 0bT3_MOD_CAPRWTimer3 mode selection bit. If this bit is 0, Timer3 works in timer/count or PWM mode.If this bit is 1, it works in capture mode.0  In capture mode, bT3_CAP_M1 and bT3_CAP_M0 select the capture edge: when bT3_CAP_M1 and bT3_CAP_M0 are 00, the capture mode is turned off or suspended; when it is 01, the edge is activated by any edge, that is, the change in level, and the capture is from any edge to any edge; when it is 10 Activated by falling edge, capture from falling edge to falling edge. When it is 11, activate by rising edge, capture from rising edge to rising edge.\nIn PWM mode, bT3_CAP_M1 and bT3_CAP_M0 select the number of data repetitions: When bT3_CAP_M1 and bT3_CAP_M0 are 00, the data is not reused, that is, a new data is used every PWM cycle. When it is 01, the data is reused 4 times, that is, the same data is used for continuous 4 PWM cycles. When it is 10, the data is reused 8 times. When it is 11, the data is reused 16 times.\nDMA remaining count register (T3_DMA_CN):   BitNameAccessDescriptionReset value  [7:0]T3_DMA_CNRWThe current remaining DMA count, which can be preset to the initial value, and is automatically reduced after the DMA operation00h  DMA current buffer address (T3_DMA):   BitNameAccessDescriptionReset value  [7:0]T3_DMA_AHRWThe current high byte of the DMA address, which can be preset to the initial value. It automatically increases after DMA. Only the lower 4 bits are valid. The upper 4 bits are fixed to 0. Only the first 4K of xRAM are supported.0xh [7:0]T3_DMA_ALRWLow byte of the current DMA address, which can be preset to the initial value. It is automatically increased after DMA. Only the upper 7 bits are valid. The lowest bit is fixed at 0. Only even addresses are supported.xxh  FIFO port (T3_FIFO):   BitNameAccessDescriptionReset value  [7:0]T3_FIFO_HRWFIFO high byte of Timer3xxh [7:0]T3_FIFO_LRWFIFO low byte of Timer3xxh  12.4 PWM Function Timer3 of CH559 has a 16-bit PWM function. In addition, there are two other 8-bit PWMs. The PWM can choose the default output polarity to be low or high. It can dynamically modify the PWM output duty cycle. After the simple RC resistor and capacitor perform integral low-pass filtering, various output voltages can be obtained, which is equivalent to a low-speed digital-to-analog converter DAC.\nPWM3 output duty cycle = T3_FIFO / T3_END, the support range is 0% to 100%. If the value of T3_FIFO is greater than T3_END, it is treated as 100%.\nPWM1 output duty cycle = PWM_DATA / PWM_CYCLE, support range 0% to 100%, if the value of PWM_DATA is greater than PWM_CYCLE, it will be treated as 100%.\nPWM2 output duty cycle = PWM_DATA2 / PWM_CYCLE, the support range is 0% to 100%. If the value of PWM_DATA2 is greater than PWM_CYCLE, it is treated as 100%.\nIn practical applications, it is recommended to allow the PWM pin output and set the PWM output pin to push-pull output mode.\n12.4.1 PWM1 and PWM2  Table 12.4.1 List of PWM1 and PWM2 related registers\n   NameAddressDescriptionReset value  PWM_CYCLE9Fh3xxh PWM_CK_SE9Eh300h PWM_CTRL9Dh302h PWM_DATA9Ch3xxh PWM_DATA29Bh3xxh  PWM2 data register (PWM_DATA2):   BitNameAccessDescriptionReset value  [7:0]PWM_DATA2RWStore current data of PWM2, duty cycle of PWM2 output active level = PWM_DATA2 / PWM_CYCLExxh  PWM1 data register (PWM_DATA):   BitNameAccessDescriptionReset value  [7:0]PWM_DATARWStore the current data of PWM1, the duty cycle of PWM1 output active level = PWM_DATA / PWM_CYCLExxh  PWM control register (PWM_CTRL):   BitNameAccessDescriptionReset value  7bPWM_IE_ENDRWThis bit is 1 to enable the end of the PWM cycle or the MFM buffer empty interrupt0 6bPWM2_POLARRWWhen bPWM_MOD_MFM = 0, control the output polarity of PWM2. When this bit is 0, the default low level is valid, and the high level is valid. When the bit is 1, it is default high level and the low level is active0 6bMFM_BUF_EMPTYR0When bPWM_MOD_MFM = 1, this bit is 1 to indicate that the MFM buffer is empty0 5bPWM_POLARRWControls the polarity of PWM1 output. If this bit is 0, it defaults to low level, and the high level is valid. If this bit is 1, it defaults to high level, and the low level is valid.0 4bPWM_IF_ENDRWPWM cycle end interrupt flag bit, this bit is 1 means there is an interrupt, cleared by writing 1 or cleared by writing PWM_CYCLE or cleared when reloading data0 3bPWM_OUT_ENRWPWM1 output enable, this bit is 1 to enable PWM1 output0 2bPWM2_OUT_ENRWWhen bPWM_MOD_MFM = 0, this bit is 1 to enable PWM2 output0 2bMFM_BIT_CNT2R0When bPWM_MOD_MFM = 1, it indicates the current MFM encoding progress. This bit is 0 to indicate that the lower 4 bits are being processed. A 1 indicates that the upper 4 bits are being processed.0 1bPWM_CLR_ALLRWThis bit is 1 to clear the PWM1 and PWM2 counts and FIFOs and needs to be cleared by software1 0bPWM_MOD_MFMRWMFM encoding mode is enabled, this bit is 0 for PWM mode. This bit is 1 for MFM mode 0  PWM clock division setting register (PWM_CK_SE):   BitNameAccessDescriptionReset value  [7:0]PWM_CK_SERWSetting the PWM Clock Divisor00h  PWM cycle period register (PWM_CYCLE):   BitNameAccessDescriptionReset value  [7:0]PWM_CYCLERWSet the PWM cycle period, when the value is 00h, it means 100hxxh  12.5 Timer Function 12.5.1 Timer0/1  Set T2MOD to select the internal clock frequency of the timer. If bTn_CLK (n = 0/1) is 0, then the clock corresponding to Timer0/1 is Fsys/12; if bTn_CLK is 1, then select Fsys by bTMR_CLK = 0 or 1. / 4 or Fsys as the clock. Set the TMOD to configure the working mode of the timer. Set the timer/counter initial values TLn and THn (n = 0/1). Set the bit TRn (n = 0/1) in TCON to start or stop the timer/counter. It can be queried by bit TFn (n = 0/1) or detected by interrupt mode.  Mode 0: 13-bit timer/counter  Figure 12.5.1.1 Timer0/1 Mode 0\n Mode 1: 16-bit timer/counter  Figure 12.5.1.2 Timer0/1 Mode 1\n Mode 2: Automatic reload 8-bit timer/counter  Figure 12.5.1.3 Timer0/1 Mode 2\n Mode 3: Timer0 is decomposed into two independent 8-bit timers and counters, and the TR1 control bit of Timer1 is borrowed. Timer1 replaces the borrowed TR1 control bit by whether to start mode 3, Timer1 enters mode 3, and Timer1 stops running.  Figure 12.5.1.4 Timer0 Mode 3\n 12.5.2 Timer2 Timer2 16-bit reload timer/counter mode:\n Set the bits RCLK and TCLK in T2CON to 0, and select the non-serial port baud rate generator mode. Set bit C_T2 in T2CON to 0. Select to use the internal clock, go to step (3). Can also set to 1 to select the falling edge of the T2 pin as the count clock, skip step (3). Set T2MOD to select the internal clock frequency of the timer. If bT2_CLK is 0, the clock of Timer2 is Fsys / 12. If bT2_CLK is 1, then select Fsys / 4 or Fsys as the clock by T.R_CLK = 0 or 1. Set the bit CP_RL2 of T2CON to 0 and select the 16-bit reload timer / counter function of Timer2. Set RCAP2L and RCAP2H to the reload value after the timer overflows, set TL2 and TH2 to the initial value of the timer (generally the same as RCAP2L and RCAP2H), set TR2 to 1, and t.rt Timer2. The current timer / counter status can be obtained by querying the TF2 or timer 2 interrupts.   Figure 12.5.2.1 Timer2 16-bit reload timer/counter\n Timer2 clock output mode:\nRefer to the 16-bit reload timer / counter mode, and then set bit T2OE in T2MOD to 1 to enable the output of the TF2 frequency divided clock from the T2 pin.\nTimer2 serial port 0 baud rate generator mode:\n Set bit C_T2 in T2CON to 0 to choose to use the internal clock or set it to 1 to select the falling edge of the T2 pin as the clock. Set the RCLK and TCLK in T2CON to 1 or one of h.m as required. selecting the baud rate generator mode. Set T2MOD to select the internal clock frequency of the timer. If bT2_CLK is 0, then the clock of Timer2 is Fsys / 4. If bT2_CLK is 1, then bTMR_CLK = 0 or 1 selects Fsys / 2 or Fsys as the clock. (3) Set RCAP2L and RCAP2H to the reload value after the timer overflows, set TR2 to 1, and start Timer2.   Figure 12.5.2.2 Timer2 UART0 Baud Rate Generator\n Timer2 dual channel capture mode:\n Set the bits RCLK and TCLK in T2CON to 0, and select the non-serial port baud rate generator mode. Set the bit C_T2 in T2CON to 0. Select to use the internal clock and go to step (3); also set it to select the falling edge of the T2 pin as the count clock and skip step (3). Set T2MOD to select the internal clock frequency of the timer. If bT2_CLK is 0, the clock of Timer2 is Fsys/12. If bT2_CLK is 1, then select Fsys/4 or Fsys as the clock by T.R_CLK = 0 or 1. Set the bits bT2_CAP_M1 and bT2_CAP_M0 of T2MOD to select the corresponding edge capture mode. Set the bit CP_RL2 of T2CON to 1 to select the capture function of T2EX pin by Timer2. Set TL2 and TH2 to the initial values ​​of the timer, set TR2 to 1, and start Timer2. When the CAP2 capture is completed, RCAP2L and RCAP2H will save the current TL2 and TH2 count values ​​and set EXF2 to generate an interrupt.The next captured RCAP2L and RCAP2H i.l be between the last captured RCAP2L and RCAP2H The difference is the signal width between the two valid edges. If bit C_T2 in T2CON is 0 and bit bT2_CAP1_EN in T2MOD is 1, then the capture function of Timer2 on the T2 pin will be enabled at the same time. When CAP1 capture is completed, T2CAP1L and T2CAP1H will save the current TL2 and TH2 And the CAP1F bit is set to generate an interrupt.   Figure 12.5.2.3 Timer2 capture mode\n 12.5.3 Timer3  Set the bit bT3_EN_CK_SE in T3_SETUP to 1, enable the Timer3 clock division setting register T3_CK_SE, set the division factor, and count the clock to Fsys / T3_CK_SE. Clear T._EN_CK_SE after the setting is completed. Set the T3_END counting end value or the total number of PWM cycles. Turn on interrupt enable in T3_SETUP as required. Set each control bit in T3_CTRL, select the mode, and clear bT3_CLR_ALL, set bT3_CNT_EN to start Timer3. Set T3_DMA_AL and T3_DMA_AH and T3_DMA_CN as required, set bT3_DMA_EN to enable the DMA function.   Figure 12.5.3.1 Timer3 16-bit timer/PWM/capture\n Data format captured by Timer3:\nTimer3 can be used to capture the width between two valid edges of the signal.The width is expressed by the divided clock count. During or after the capture, the width data can be obtained through DMA or directly reading the FIFO.The data is 16 bits. The most significant bit is the identification bit and the lower 15 bits are the width count. After signal capture is enabled, data will be generated every time a valid edge is detected or every timer overflows.Because the data generated at the first valid edge is the width from the time when signal capture is enabled, not two valid edges Width, so the first data captured is usually discarded.\n(1). bT3_CAP_M1 and bT3_CAP_M0 = 11\nThe rising edge is valid, capturing the signal width from the rising edge to the rising edge, that is, the rising edge is activated. If the highest bit of the data is 1, it means that the signal width has overflowed the counting end value, that is, if the timing exceeds T3_END and the next rising edge has not been found, the width value must be added to the width of the next data whose highest bit is 0. The most significant bit is 0, which means that the width is the width between the end of a certain rising edge, and whether the lower 15 bits are accumulated forward according to whether the most significant bit of some previous data is 1. In this mode, it is recommended to set T3_END to detect ultra-wide signals or end signals for special purposes, and normal signals should not overflow.\nFor example, T3_END is set to 4000h, and the raw data sequence collected is as follows\n1234h, 2345h, 0456h, C000h, C000h, 1035h, 3579h, C000h, 2468h, and 0987h are combined to obtain the interval between each rising edge: 1234h, 2345h, 0456h, 9035h, 3579h, 6468h, 0987h\n(2). bT3_CAP_M1 and bT3_CAP_M0 = 10\nSame as above, but the falling edge is valid, capturing the signal width from the rising edge to the falling edge, that is, the falling edge is activated.\n(3). bT3_CAP_M1 and bT3_CAP_M0 = 01\nAny edge is valid, capturing the signal width from any edge to any edge, that is, the level change is activated. If the highest bit of the data is 1, then the width is a high-level width, that is, from the rising edge to the falling edge. If the highest bit of the data is 0, then the width is a low-level width, that is, from the falling edge to the rising edge. The lower 15 bits after masking the most significant bits are width values counted by the divided clock. In this mode, it is recommended to set T3_END to a larger value to avoid timing overflow, but it must not exceed 15 digits of valid data.\n"});index.add({'id':12,'href':'/docs/13-uart/','title':"13. UART",'content':"13. Universal asynchronous transceiver UART 13.1 Introduction to UART CH559 chip provides two full-duplex asynchronous serial ports: UART0 and UART1. UART0 is a standard MCS51 serial port. Its data reception and transmission are realized through SBUF access to physically separate transmit / receive registers. The data written to SBUF is loaded into the transmit register, and the read operation to SBUF corresponds to the receive buffer register.\nUART1 is an enhanced asynchronous serial port with the following features:\n Compatible with 16C550 asynchronous serial port and enhanced. Support 5, 6, 7 or 8 data bits and 1 or 2 stop bits. support odd, even, no parity, blank 0, flag 1 and other verification methods. Programmable communication baud rate, supporting 115200bps and communication baud rate up to 3Mbps. .Built-in independent transmit and receive buffers and 8-byte FIFO FIFO buffer, support 4 FIFO trigger levels. Support MODEM modem signals CTS, DSR, RI, DCD, DTR, RTS, can be externally converted to RS232 level. Support hardware flow control signals CTS and RTS automatic handshake and automatic transmission rate control, compatible with TL16C550C. Support for serial frame error detection and Break line interval detection. Built-in SIR infrared codec, support IrDA infrared communication with baud rate of 2400bps to 115200bps. Supports full-duplex and half-duplex serial communication, and provides a status pin for switching RS485. Built-in half-duplex differential transceiver, directly supports simple long-distance multi-machine communication similar to RS485 bus. Support to preset the address when this machine is used as a slave, used to automatically match the data packets on the bus when multi-machine communication.  13.2 UART Register  Table 13.2.1 List of UART related registers\n   NameAddressDescriptionReset value  SBUF 99h UART0 data register xxh SCON 98h UART0 Control Register 00h SER1_DLL 9Ah UART1 baud rate divisor latch low byte xxh SER1_RBR 9Ah UART1 data receive buffer register (read only) xxh SER1_THR 9Ah UART1 data transmission holding register (write only) xxh SER1_FIFO 9Ah UART1 data FIFO read and write register xxh SER1_DIV 97h UART1 prescaler divisor register xxh SER1_ADDR 97h UART1 bus address preset register FFh SER1_MSR 96h Modem MODEM status register (read only) F0h SER1_LSR 95h UART1 line status register (read only) 60h SER1_MCR 94h Modem MODEM control register 00h SER1_LCR 93h UART1 line control register 00h SER1_IIR 92h UART1 interrupt identification register (read only) 01h SER1_FCR 92h FIFO control register (write only) 00h SER1_DLM 91h UART1 baud rate divisor latch high byte 80h SER1_IER 91h UART1 interrupt enable register 00h  13.2.1 UART0 Register Description UART0 control register (SCON):   BitNameAccessDescriptionReset value  7SM0RWUART0 working mode selection bit 0, this bit is 0 selects 8-bit data asynchronous communication; this bit is 1 selects 9-bit data asynchronous communication0 6SM1RWUART0 working mode selection bit 1, this bit is 0 to set the fixed baud rate. This bit is 1 to set the variable baud rate, generated by timer T1 or T20 5SM2RWUART0 multi-machine communication control bit:\nWhen receiving data in modes 2 and 3, when SM2 = 1, if RB8 is 0, then RI is not set to 1, reception is invalid. If RB8 is 1, then RI is set to 1, reception is valid. When SM2 = 0\nWhen RB8 is 0 or 1, RI is set when receiving data, and the reception is valid. In mode 1, if SM2 = 1, then the reception is valid only when a valid stop bit is received. In mode 0, SM2 Bit must be set to 0\n0 4RENRWUART0 enable reception control bit, this bit is 0 to disable reception; this bit is 1 to enable reception0 3TB8RWThe 9th bit of the transmitted data. In modes 2 and 3, TB8 is used to write the 9th bit of the transmitted data, which can be a parity bit.In multi-machine communication, it is used to indicate whether the host sends an address byte Data byte, TB8 = 0 is data, TB8 = 1 is address0 2RB8RWThe 9th bit of the received data, in modes 2 and 3, RB8 is used to store the 9th bit of received data. In mode 1, if SM2 = 0, then RB8 is used to store the received stop bit. In mode 0 Without using RB80 1TIRWSend interrupt flag bit, which is set by hardware after a data byte is transmitted and needs to be cleared by software0 0RIRWReceive interrupt flag bit, which is set by hardware after a data byte is received and needs to be cleared by software0   Table 13.2.1.1 UART0 working mode selection\n   SM0SM1Description  0 0 Mode 0, shift register mode, fixed baud rate is Fsys / 12 0 1 Mode 1, 8-bit asynchronous communication mode, variable baud rate, generated by timer T1 or T2 1 0 mode 2, 9-bit asynchronous communication mode, the baud rate is Fsys / 128 (SMOD = 0) or Fsys / 32 (SMOD = 1) 1 1 Mode 3, 9-bit asynchronous communication, variable baud rate, generated by timer T1 or T2  In modes 1 and 3, when RCLK = 0 and TCLK = 0, the UART0 baud rate is generated by timer T1. T1 should be set to mode 2 auto-reload 8-bit timer mode, bT1_CT and bT1_GATE must both be 0, divided into the following types of clock situations.\n Table 13.2.1.2 Calculation formula of UART0 baud rate generated by T1\n   bTMR_CLKbT1_CLKSMODDescription  1 1 0 TH1 = 256-Fsys/32/ baud rate 1 1 1 TH1 = 256-Fsys/16/ baud rate 0 1 0 TH1 = 256-Fsys/4/32/ baud rate 0 1 1 TH1 = 256-Fsys/4/16/ baud rate X 0 0 TH1 = 256-Fsys/12/32/ baud rate X 0 1 TH1 = 256-Fsys/12/16/ baud rate  In modes 1 and 3, when RCLK = 1 or TCLK = 1, the baud rate of UART0 is generated by timer T2. T2 should be set to 16-bit automatic re-carrier rate generator mode, C_T2 and CP_RL2 must both be 0, divided into the following types of clock situations.\n Table 13.2.1.3 Calculation formula of UART0 baud rate generated by T2\n   bTMR_CLKbT2_CLKDescription  1 1 RCAP2 = 65536-Fsys/16 / baud rate 0 1 RCAP2 = 65536-Fsys/2/16 / baud rate X 0 RCAP2 = 65536-Fsys/4/16 / baud rate  UART0 data register (SBUF):   BitNameAccessDescriptionReset value  [7:0]SBUFRWUART0 data register, including sending and receiving two physically separate registers. Writing data to SBUF corresponds to the transmit data register. Reading data from SBUF corresponds to the receive data registerxxh  13.2.2 UART1 Related Registers UART1 data FIFO read and write register SER1_FIFO, including data receiving buffer register SER1_RBR and data transmission holding register SER1_THR two physically separate registers.\nData receive buffer register (SER1_RBR), only valid when bLCR_DLAB = 0:   BitNameAccessDescriptionReset value  [7:0]SER1_RBRROSerial port receive buffer register. If the bLSR_DATA_RDY bit of SER1_LSR is 1, you can read the received data from this register. If bFCR_FIFO_EN is 1, the data received from the serial port shift register is first stored in the receive FIFO and then passed This register readsxxh  Data transmission holding register (SER1_THR), only valid when bLCR_DLAB = 0:   BitNameAccessDescriptionReset value  [7:0]SER1_THRWOThe serial port transmission holding register, including the transmission FIFO, is used to write the data to be transmitted. If bFCR_FIFO_EN is 1, the written data is first stored in the transmission FIFO and then output one by one through the transmission shift registerxxh  Interrupt enable register (SER1_IER), only valid when bLCR_DLAB = 0:   BitNameAccessDescriptionReset value  12345 7 bIER_RESET RW Serial port software reset control bit. This bit is 1 to reset the serial port. This bit can be automatically cleared without software clear 0 6 bIER_EN_MODEM_O RW UART1 Modem signal output enable bit, this bit is 1 to enable MODEM signal RTS / DTR output, this bit is 0 to disable output 0 5 bIER_PIN_MOD1 RW UART1 pin mode selection high 0 4 bIER_PIN_MOD0 RW UART1 pin mode selection low 0 3 bIER_MODEM_CHG RW Modem input status change interrupt enable bit, this bit is 1 to enable the modem input status change interrupt. This bit is 0 to disable 0 2 bIER_LINE_STAT RW Receive line status interrupt enable bit, this bit is 1 to enable the receive line status interrupt. This bit is 0 to disable 0 1 bIER_THR_EMPTY RW Transmit Holding Register Empty Interrupt Enable Bit. This bit is 1 to enable the transmit holding register empty interrupt. This bit is 0 to disable. 0 0 bIER_RECV_RDY RW Received data interrupt enable bit, this bit is 1 to enable generation of receive data completion interrupt and subsequent timeout interrupt of received data, this bit is 0 disable 0  The pin mode of UART1 consists of both bIER_PIN_MOD1 and bIER_PIN_MOD0 and bUH1_DISABLE, bXBUS_CS_OE, bXBUS_AL_OE, bALE_CLK_EN are combined to select different configurations.Among them, the last four can be combined into RS485EN:\n RS485EN = bUH1_DISABLE \u0026 ~ ( bXBUS_CS_OE \u0026 ~ bXBUS_AL_OE | bALE_CLK_EN )\n   RS485ENbIER_PIN_MOD1bIER_PIN_MOD0Description  x 0 0 RXD1 uses pin P4.0, TXD1 disables output 0 1 0 RXD1 and TXD1 use pins P2.6 / RXD1 and P2.7 / TXD1 respectively 0 0 1 RXD1 and TXD1 use pins P4.0 / RXD1_ and P4.4 / TXD1_ respectively 0 1 1 RXD1 and TXD1 and TNOW use pins P2.6 and P2.7 and P2.5 respectively 1 1 0 RXD1 and TXD1 share iRS485 differential pins XA and XB 1 0 1 RXD1 and TXD1 use pins XA and XB together, TNOW uses pin P4.4 1 1 1 RXD1 and TXD1 use pins XA and XB together, TNOW uses pin P2.5  The last three configurations in the above table are iRS485 half-duplex communication mode.At this time, RS485EN = 1, RXD1 and TXD1 use iRS485 differential pins XA and XB together. Through the built-in half-duplex differential transceiver, it directly supports simple RS485 Long-distance multi-machine communication of the bus.\nIn iRS485 half-duplex communication mode, the following parameters need to be set:\n Set bMCR_HALF in SER1_MCR to 1, half-duplex transceiver mode; Set bUH1_DISABLE in UHUB1_CTRL to 1 to disable the HP / HM pin.  Interrupt Identification Register (SER1_IIR):   BitNameAccessDescriptionReset value  [7:6]MASK_U1_IIR_IDR0FIFO enable flag, 11 means FIFO is enabled00b [5:4]reservedR0reserved00b [3:0]MASK_U1_IIR_INTR0UART1 interrupt status flag0001b 0bIIR_NO_INTR0UART1 is interrupt flag, it is 1 without interrupt. 0 is interrupt1  The interrupt status of UART1 is composed of 4 bits, bIIR_INT_FLAG3, bIIR_INT_FLAG2, bIIR_INT_FLAG1, and bIIR_INT_FLAG0. MASK_U1_IIR_INT is used as the serial port interrupt flag of UART1. The specific interrupts are shown in the following table.\n  NameAddressInterrupt typeInterrupt sourceClear interrupt method  U1_INT_SLV_ADDR0EhBus address matchReceived 1 data is the serial bus address, and the address matches the preset value or broadcast addressRead SER1_IIR or disable multi-machine mode U1_INT_LINE_STAT06hReceive line statusbLSR_OVER_ERR or bLSR_PAR_ERR or bLSR_FRAME_ERR or bLSR_BREAK_ERRRead SER1_LSR U1_INT_RECV_RDY04hReceive data availableThe number of received bytes reaches the trigger point of the FIFORead SER1_RBR U1_INT_RECV_TOUT0ChReceive data timeoutData has been received, but the next data has not been received for more than 4 data bytesRead SER1_RBR U1_INT_THR_EMPTY02hSER1_THR register is emptyThe transmit holding register is empty, and bIER_THR_EMPTY changes from 0 to 1 to re-enable the interruptRead SER1_IIR or write SER1_THR U1_INT_MODEM_CHG00hMODEM input change△ CTS or △ DSR or △ RI or △ DCDRead SER1_MSR U1_INT_NO_INTER01hNo interruptionWithout interruption  FIFO control register (SER1_FCR):   BitNameAccessDescriptionReset value  7bFCR_FIFO_TRIG1W0Receive FIFO interrupt and hardware flow control trigger point set high0 6bFCR_FIFO_TRIG0W0Receive FIFO interrupt and hardware flow control trigger point set low0 [5:3]reservedR0reserved000b 2bFCR_T_FIFO_CLRW0Send FIFO data clear enable bit, this bit is 1 to clear the data in the transmit FIFO (excluding the data being transmitted). This bit can be automatically cleared without software clearing0 1bFCR_R_FIFO_CLRW0Receive FIFO data clear enable bit, this bit is 1 to clear the data in the receive FIFO (excluding the data being received). This bit can be cleared automatically without software clearing0 0bFCR_FIFO_ENW0FIFO enable bit, this bit is 1 to enable FIFO; this bit is 0 to disable FIFO. After disabling FIFO, it is 16C450 compatible mode, which is equivalent to FIFO having only one byte depth.It is recommended to enable FIFO0  bFCR_FIFO_TRIG1 and bFCR_FIFO_TRIG0 form MASK_U1_FIFO_TRIG, which is used to set the interrupt point of the receive FIFO and the trigger point of hardware flow control: 11 corresponds to 7 bytes, that is, the reception of full 7 bytes generates an interrupt that is available for receiving data. When = 1, the level of the RTS pin is automatically disabled. 10 corresponds to 4 bytes. 01 corresponds to 2 bytes. 00 corresponds to 1 byte.\nLine Control Register (SER1_LCR):   BitNameAccessDescriptionReset value  7bLCR_DLABRWBaud rate divisor latch access enable bit. This bit is 0 to enable access to the registers SER1_RBR, SER1_THR, SER1_IER, SER1_ADR. This bit is 1 to enable access to the registers SER1_DLL, SER1_DLM, SER1_DIV0 6bLCR_BREAK_ENRWForce BREAK line interval enable bit, this bit is 0, no BREAK output is generated. This bit is 1, force BREAK output0 5bLCR_PAR_MOD1RWHigh parity mode0 4bLCR_PAR_MOD0RWLow parity mode0 3bLCR_PAR_ENRWParity enable bit. This bit is 0. There is no parity bit. This bit is 1 to allow parity check bits to be generated during transmission and received during reception.0 2bLCR_STOP_BITRWStop bit format setting bit, this bit is 0, there is a stop bit; this bit is 1, there are two stop bits0 1bLCR_WORD_SZ1RWData word length set high0 0bLCR_WORD_SZ0RWData word length set low0  The combination of bLCR_PAR_MOD1 and bLCR_PAR_MOD0 sets the format of the parity bit when bLCR_PAR_EN is 1: 00 for odd parity, 01 for even parity, 10 for flag bit (MARK, set to 1), and 11 for blank bit (SPACE, cleared to 0) ).\nThe combination of bLCR_WORD_SZ1 and bLCR_WORD_SZ0 sets the word length of a single data without parity: 00 is 5 data bits, 01 is 6 data bits, 10 is 7 data bits, and 11 is 8 data bits.\nMODEM control register (SER1_MCR):   BitNameAccessDescriptionReset value  7bMCR_HALFRWHalf-duplex transmit / receive mode enable bit. This bit is 0 to disable the half-duplex transmit / receive mode and support full duplex. The bit is 1 to enter the automatic half-duplex transmit / receive mode. Sending takes priority. Receiving is suspended during transmission. For receiving0 6bMCR_TNOWRWRTS pin function selection bit, this bit is 0 for standard RTS output; this bit is 1 for TNOW output, and the state of output is being transmitted, which can be used to control the half-duplex mode of RS485.0 5bMCR_AUTO_FLOWRWCTS and RTS hardware automatic flow control enable bit, this bit is 0 to disable hardware flow control. This bit is 1 to enable hardware automatic flow control.After hardware flow control is enabled, the serial port will continue to send the next data only when the CTS pin input is active low, otherwise the serial port transmission will be suspended. After hardware flow control is enabled, if bMCR_RTS is 1, then when the receive FIFO is empty, The serial port will automatically activate the low-level RTS pin automatically. When the number of bytes received reaches the trigger point of the FIFO, the serial port will automatically invalidate the RTS pin and be able to activate the RTS pin again when the receive FIFO is empty. After enabling hardware flow control CTSA change in input state does not generate a MODEM state interrupt. By connecting your own CTS pin to the other's RTS pin and sending your own RTS pin to the other's CTS pin, you can implement hardware automatic rate control0 4bMCR_LOOPRWTest mode enable bit for internal loop, this bit is 0 to disable internal loop test. This bit is 1 to enable internal loop test. In the internal loop test mode, all external output pins of the serial port are inactive.TXD1 internally returns to RXD1, RTS internally returns to CTS, DTR internally returns to DSR, OUT1 internally returns to RI, and OUT2 internally returns to DCD.0 3bMCR_OUT2RWSerial port interrupt request output enable bit, this bit is 0 to disable the serial port interrupt request output, this bit is 1 to enable the serial port interrupt request output0 2bMCR_OUT1RWUser-defined MODEM control bit, no actual output pin is connected, used for internal loop test, or as a general-purpose data bit0 1bMCR_RTSRWRTS pin output control bit. When this bit is 0, the RTS pin output is invalid (high level). When the bit is 1, the RTS pin output is valid (low level)0 0bMCR_DTRRWDTR pin output control bit. When this bit is 0, the DTR pin output is invalid (high level). When the bit is 1, the DTR pin output is valid (low level)0  Line Status Register (SER1_LSR):   BitNameAccessDescriptionReset value  7bLSR_ERR_R_FIFOR0Error flag of the receive FIFO. This bit is 1 indicating that there is at least one bLSR_PAR_ERR, bLSR_FRAME_ERR, or bLSR_BREAK_ERR error in the receive FIFO.0 6bLSR_T_ALL_EMPR0Transmit related register full empty flag bit, this bit is 1 means the transmit holding register SER1_THR and FIFO and transmit shift register are empty1 5bLSR_T_FIFO_EMPR0This bit is 1 to indicate that the transmit holding registers SER1_THR and FIFO are empty1 4bLSR_BREAK_ERRR0When this bit is 1, it indicates that BREAK line interval status is detected0 3bLSR_FRAME_ERRR0This bit is 1 to indicate that the current data in the receive FIFO is framing, and a valid stop bit is missing0 2bLSR_PAR_ERRR0This bit is 1 to indicate the parity error of the current data in the receive FIFO0 1bLSR_OVER_ERRR0This bit is 1 to indicate the receive FIFO buffer overflow0 0bLSR_DATA_RDYR0This bit is 1 to indicate that there is received data in the receive FIFO. After reading all the data in the FIFO, this bit is automatically cleared to 00  Modem MODEM status register (SER1_MSR):   BitNameAccessDescriptionReset value  7bMSR_DCDR0This bit is the bit inversion of the DCD pin. A value of 1 indicates that the DCD pin is active (active low)1 6bMSR_RIR0This bit is the bit inversion of the RI pin. A 1 indicates that the RI pin is active (active low)1 5bMSR_DSRR0This bit is the bit inversion of the DSR pin. A value of 1 indicates that the DSR pin is active (active low)1 4bMSR_CTSR0This bit is the bit inversion of the CTS pin. A 1 indicates that the CTS pin is active (active low)1 3bMSR_DCD_CHGR0This bit is 1 to indicate that the input status of the DCD pin has changed.0 2bMSR_RI_CHGR0This bit is 1 to indicate that the input state of the RI pin has changed0 1bMSR_DSR_CHGR0This bit is 1 to indicate that the input state of the DSR pin has changed0 0bMSR_CTS_CHGR0This bit is 1 to indicate that the CTS pin input state has changed0  UART1 bus address preset register (SER1_ADDR), only valid when bLCR_DLAB = 0:   BitNameAccessDescriptionReset value  [7:0]SER1_ADDRRWPreset bus address for automatic comparison in multi-machine communicationFFh  SER1_ADDR presets the address when this machine is used as a slave. It is used to automatically compare the received addresses during multi-machine communication, and to generate an interrupt when the addresses match or when it receives the broadcast address 0FFH, and at the same time allow receiving subsequent data packets. Do not receive any data before the address does not match. After starting to send data or after rewriting the SER1_ADDR register, stop receiving any data until the next time the address matches again or the broadcast address is received.\nWhen SER1_ADDR is 0FFH or bLCR_PAR_EN = 0, the automatic comparison of bus addresses is disabled.\nWhen SER1_ADDR is not 0FFH and bLCR_PAR_EN = 1, the automatic comparison of the bus address is enabled, and the following parameters should be configured: bLCR_WORD_SZ1 and bLCR_WORD_SZ0 are both 1 to select 8 data bits. BLCR_PAR_MOD1 is always 1. For the address byte is MARK In the case where bit 9 of the data byte is 0, bLCR_PAR_MOD0 should be set to 1.For the case where the address byte is SPACE (that is, bit 9 of the data byte is 1), bLCR_PAR_MOD0 should be set to 0, that is, select according to the data byte.\nUART1 baud rate divisor latch (SER1_DLM, SER1_DLL), only valid when bLCR_DLAB = 1:   BitNameAccessDescriptionReset value  [7:0]SER1_DLLRWSER1_DLL is the low byte and SER1_DLM is the high byte. The two form a 16-bit divisor and are used for a serial baud rate generator composed of a 16-bit counter. These registers can only be read and written when bLCR_DLAB is 1. The divisor = Fsys * 2 / SER1_DIV / 16 / baud ratexxh [7:0]SER1_DLMRW80h  UART1 prescaler divisor register (SER1_DIV), only valid when bLCR_DLAB = 1:   BitNameAccessDescriptionReset value  [7:0]SER1_DIVRWIt is used to multiply the system main clock Fsys and then pre-divide to generate the internal reference clock of the serial port baud rate generator. This register can only be read and written when bLCR_DLAB is 1xxh  13.3 UART Application UART0 application:  Select the baud rate generator of UART0, you can choose from timer T1 or T2, and configure the corresponding counter. Start the timer. Set SM0, SM1, and SM2 of SCON to select the working mode of serial port 0. Set REN to 1 to enable UART0 reception. You can set the serial port interrupt or query the RI and TI interrupt status. Read and write SBUF implements serial data transmission and reception, the allowable baud rate error of the serial port receiving signal is not greater than 2%.  UART1 application:  Set the bit bLCR_DLAB of SER1_LCR to 1, write the UART1 prescaler register SER1_DIV, calculate the baud rate divisor according to the baud rate, the divisor = Fsys / 8 / SER1_DIV / baud rate, and the high n. low bytes of the divisor are written to SER1_DLM And SER1_DLL. Set SER1_LCR, select the appropriate serial data format, data byte, and parity mode. Optional setting SER1_IER, select UART1 interrupt status trigger. If the interrupt mode is used, the bit bMCR_OUT2 of SER1_MCR needs to be set to 1 to enable the interrupt output; otherwise, the interrupt status bit needs to be queried actively. Read and write SER1_FIFO to realize serial data transmission and reception, the allowable baud rate error of the serial port receiving signal is not greater than 2%.  "});index.add({'id':13,'href':'/docs/14-spi/','title':"14. SPI",'content':"14. Synchronous Serial Interface SPI 14.1 Introduction to SPI CH559 chip provides 2 SPI interfaces for high-speed synchronous data transmission with peripherals.\nSPI0 features:\n Support master mode and slave mode. Support mode 0 and mode 3 clock mode. Optional 3-wire full duplex or 2-wire half duplex mode. Optional MSB high bit is transmitted first or LSB low bit is transmitted first. The clock frequency is adjustable, up to half of the system main frequency. Built-in 3-byte receive FIFO and 1-byte transmit FIFO. Support multiple interrupts.  SPI1 features:\n Only support master mode, MSB high bit is sent first. Support mode 0 and mode 3 clock mode. Optional 3-wire full duplex or 2-wire half duplex mode. The clock frequency is adjustable, up to half of the system main frequency.  14.2 SPI Register  Table 14.2.1 List of SPI Related Registers\n   NameAddressDescriptionReset value  SPI0_SETUP FCh SPI0 setup register 00h SPI0_S_PRE FBh SPI0 Slave Mode Preset Data Register 20h SPI0_CK_SE FBh SPI0 Clock Divider Setting Register 20h SPI0_CTRL FAh SPI0 Control Register 02h SPI0_DATA F9h SPI0 data transmit / receive register xxh SPI0_STAT F8h SPI0 status register 08h SPI1_CK_SE B7h SPI1 clock divider setting register 20h SPI1_CTRL B6h SPI1 control register 02h SPI1_DATA B5h SPI1 data transmission and reception register xxh SPI1_STAT B4h SPI1 status register 08h  14.2.1 SPI0 Related Registers SPI0 setup register (SPI0_SETUP):   BitNameAccessDescriptionReset value  7bS0_MODE_SLVRWSPI0 master-slave mode selection bit, if this bit is 0, SPI0 is master mode. If this bit is 1, SPI0 is slave mode / device mode0 6bS0_IE_FIFO_OVRWFIFO overflow interrupt enable bit in slave mode, this bit is 1 to enable FIFO overflow interrupt. If this bit is 0, FIFO overflow does not generate interrupt0 5bS0_IE_FIRSTRWReceive the first byte to complete the interrupt enable bit in slave mode. When this bit is 1, the interrupt is triggered when the first data byte is received in slave mode. When the bit is 0, no interrupt is generated when the first byte is received.0 4bS0_IE_BYTERWData byte transfer completion interrupt enable bit, this bit is 1 to enable byte transfer completion interrupt. When this bit is 0, byte transfer completion does not generate an interrupt0 3bS0_BIT_ORDERRWBit order control bit of the data byte. If this bit is 0, the MSB high-order bit comes first. If this bit is 1, the LSB low-order bit comes first.0 2reservedR0reserved0 1bS0_SLV_SELTR0Chip select active status bit in slave mode, this bit is 0 if it is not currently selected. This bit is 1 if it is currently selected0 0bS0_SLV_PRELOADR0Preload data status bit in slave mode, this bit is 1 to indicate that it is currently in the preload status after the chip select is valid but before the data has been transferred0  SPI0 clock divider setting register (SPI0_CK_SE):   BitNameAccessDescriptionReset value  [7:0]SPI0_CK_SERWSetting the SPI0 Clock Divider in Master Mode20h  SPI0 Slave Mode Preset Data Register (SPI0_S_PRE):   BitNameAccessDescriptionReset value  [7:0]SPI0_S_PRERWPreload the first transfer data in slave mode20h  SPI0 control register (SPI0_CTRL):   BitNameAccessDescriptionReset value  7 bS0_MISO_OE RW MISO output enable control bit for SPI0, this bit is 1 to enable output. This bit is 0 to disable output 0  6 bS0_MOSI_OE RW SPI0 MOSI output enable control bit, this bit is 1 to enable output. This bit is 0 to disable output 0  5 bS0_SCK_OE RW SCK output enable control bit for SPI0, this bit is 1 to enable output. This bit is 0 to disable output 0  4 bS0_DATA_DIR RW SPI0 data direction control bit. This bit is 0 to output data. Only write FIFO is used as a valid operation to start an SPI transmission. This bit is 1 to input data and write or read FIFO are both a valid operation to start a SPI transmission 0  3 bS0_MST_CLK RW SPI0 Master clock mode control bit, this bit is 0 for mode 0, the default low level when SCK is idle. 1 for mode 3, SCK default high level 0  2 bS0_2_WIRE RW SPI0 2-wire half-duplex mode enable bit. If this bit is 0, 3-wire full-duplex mode, including SCK, MOSI, and MISO. This bit is 1 2-wire half-duplex mode, including SCK, MISO. 0  1 bS0_CLR_ALL RW This bit is 1 to clear the SPI0 interrupt flag and FIFO, which needs to be cleared by software 1  0 bS0_AUTO_IF RW Enable bit for automatically clearing the byte reception completion interrupt flag through a valid FIFO operation. When this bit is 1, the byte reception completion interrupt flag S0_IF_BYTE is automatically cleared during a valid FIFO read and write operation. 0   SPI0 data transmit and receive register (SPI0_DATA):   BitNameAccessDescriptionReset value  [7:0]SPI0_DATARWIncluding sending and receiving two physically separate FIFOs, read operations correspond to receive data FIFOs, write operations correspond to send data FIFOs, and valid read and write operations can initiate an SPI transmissionxxh  SPI0 status register (SPI0_STAT):   BitNameAccessDescriptionReset value  7 S0_FST_ACT R0 This bit is 1 to indicate that the current status is completed when the first byte is received in slave mode  0  6 S0_IF_OV RW FIFO overflow flag in slave mode. A 1 in this bit indicates a FIFO overflow interrupt. A 0 in this bit indicates no interrupt. Clear by direct bit access or write 1 to clear. When bS0_DATA_DIR = 0, the interrupt is triggered by the sending FIFO empty. When bS0_DATA_DIR = 1, the interrupt is triggered by the receiving FIFO full. 0  5 S0_IF_FIRST RWReceives the first byte completion interrupt flag bit in slave mode. A 1 in this bit indicates that the first byte was received. Clear by direct bit access or write 1 Clear 0  4 S0_IF_BYTE RW Data byte transfer complete interrupt flag. When this bit is 1, it indicates that one byte transfer is completed. Direct bit access Clear or write 1 clear, or clear by FIFO valid operation when bS0_AUTO_IF = 1 0  3 S0_FREE R0 SPI0 idle flag bit, this bit is 1 means there is no SPI shift at present, usually in the gap period between data bytes 1  2 S0_T_FIFO R0 SPI0 transmit FIFO count, valid value is 0 or 1 0  1 S0_R_FIFO1 R0 SPI0 receive FIFO count bit 1Valid values are 0 or 1 or 2 or 3 0  0 S0_R_FIFO0 R0 SPI0 receive FIFO count bit 0 0   14.2.2 SPI1 Register Description SPI1 status register (SPI1_STAT):   BitNameAccessDescriptionReset value  [7:5]reservedROreserved000b 4bS1_IF_BYTEROData byte transfer completed interrupt flag bit. When this bit is 1, it indicates that a byte transfer is completed. Direct bit access Cleared or written 1 cleared, or cleared by valid FIFO operation when bS1_AUTO_IF = 10 3bS1_FREERWSPI1 idle flag bit, this bit is 1 means there is no SPI shift at present, usually in the gap period between data bytes1 [2:0]reservedROreserved000b  SPI1 data transmit and receive register (SPI1_DATA):   BitNameAccessDescriptionReset value  [7:0]SPI1_DATARWIt is actually an SPI data shift register. Read is used to receive data and write is used to send data. Effective read and write operations can start an SPI transfer.xxh  SPI1 control register (SPI1_CTRL):   BitNameAccessDescriptionReset value  12345 7 bS1_MISO_OE RW MISO1 output enable control bit for SPI1, this bit is 1 to enable output. This bit is 0 to disable output0 6 Reserved RO reserved0 5 bS1_SCK_OE RW SCK1 output enable control bit for SPI1, this bit is 1 to enable SCK1 output, if bS1_2_WIRE = 0, then MOSI1 output enable will be enabled at the same time. This bit is 0 to disable output0 4 bS1_DATA_DIR RW SPI1 data direction control bit. This bit is 0 to output data. Only write SPI1_DATA as a valid operation to start an SPI transmission. This bit is 1 to input data. Writing or reading SPI1_DATA is a valid operation to start a SPI. transmission0 3 bS1_MST_CLK RW SPI1 clock mode control bit, this bit is 0 for mode 0, SCK1 defaults to low level when idle. This bit is 1 for mode 3, SCK1 defaults to high level0 2 bS1_2_WIRE RW SPI1 2-wire half-duplex mode enable bit, this bit is 0, then 3-wire full duplex mode, including SCK1, MOSI1, MISO1. This bit is 1, then 2-wire half-duplex mode, including SCK1, MISO10 1 bS1_CLR_ALL RW This bit is 1 to clear the SPI1 interrupt flag and FIFO, which needs to be cleared by software1 0 bS1_AUTO_IF RW Enable bit for automatically clearing the byte reception completion interrupt flag through the SPI1_DATA valid operation. When this bit is 1, it automatically clears the byte reception completion interrupt flag bS1_IF_BYTE when the SPI1_DATA is valid0  SPI1 clock divider setting register (SPI1_CK_SE):   BitNameAccessDescriptionReset value  [7:0]SPI1_CK_SERWSet the SPI1 clock division factor20h  14.3 SPI Transmission Format The SPI master mode supports two transmission modes, Mode 0 and Mode 3. You can select by setting bit bSn_MST_CLK in the SPI control register SPIn_CTRL. CH559 always samples MISO data on the rising edge of CLK. The data transmission format is shown in the figure below.\nMode 0: bSn_MST_CLK = 0\n Figure 14.3.1 SPI Mode 0 Timing Diagram\n Mode 3: bSn_MST_CLK = 1\n Figure 14.3.2 SPI Mode 3 Timing Diagram\n 14.4 SPI Configuration 14.4.1 SPI Master Mode Configuration In SPI master mode, the SCK pin outputs a serial clock, and the chip select output pin can be designated as any I/O pin.\nSPI0 configuration steps:\n Set the SPI clock frequency division setting register SPI0_CK_SE to configure the SPI clock frequency. Set bit bS0_MODE_SLV of the SPI setting register SPI0_SETUP to 0, and configure it as the master mode. Set the bit bS0_MST_CLK of the SPI control register SPI0_CTRL and set it to mode 0 or 3 as required. Set the bS0_SCK_OE and bS0_MOSI_OE bits of the SPI control register SPI0_CTRL to 1, and set the bS0_MISO_OE bit to 0, set the direction of P1 port bSCK, bMOSI as the output, bMISO as the input, and the chip select pin as the output.  Data sending process:\n Write the SPI0_DATA register, write the data to be sent to the FIFO, and automatically start an SPI transfer. Wait for S0_FREE to be 1, indicating that the transmission is complete, and can continue to send the next byte.  Data receiving process:\n Write the SPI0_DATA register and write any data such as 0FFh to the FIFO to start an SPI transfer. Wait for S0_FREE to be 1, indicating that the reception is complete. You can read SPI0_DATA to get the received data. If the previous bS0_DATA_DIR is set to 1, the above read operation will also start the next SPI transmission, otherwise it will not start.  14.4.2 SPI Slave Mode Configuration Only SPI0 supports slave mode. In slave mode, the SCK pin is used to receive the serial clock of the connected SPI master.\n Set bit bS0_MODE_SLV of SPI0 setting register SPI0_SETUP to 1, and configure it as slave mode. Set the bits bS0_SCK_OE and bS0_MOSI_OE of the SPI0 control register SPI0_CTRL to 0, set bS0_MISO_OE to 1, set the direction of P1 port bSCK, bMOSI and bMISO, and chip select pins as inputs. When the SCS chip select is active (low level), MISO will automatically enable the output. At the same time, it is recommended to set the MISO pin to high-impedance input mode (bP1_OC = 0, P1_DIR [6] = 0, P1_PU [6] = 0), so that MISO does not output during chip select invalidation, which facilitates sharing the SPI bus. Optional, set the SPI slave mode preset data register SPI0_S_PRE, which is used to automatically load into the buffer for external output after being selected by the chip for the first time. After 8 serial clocks, that is, the first data byte transfer is completed, CH559 gets the first byte data (possibly a command code) from the external SPI host, and the external SPI host exchanges the preset data in SPI0_S_PRE (possibly Is a status value). Bit 7 of the register SPI0_S_PRE will be automatically loaded on the MISO pin during the low period of SCK after the SPI chip select is active. For SPI mode 0, if CH559 is preset with bit 7 of SPI0_S_PRE, then the external SPI host will select the SPI chip select When the data is valid but not yet transmitted, the preset value of bit 7 of SPI0_S_PRE can be obtained by querying the MISO pin, so that the value of bit 7 of SPI0_S_PRE can be obtained only by validating the SPI chip select.  Data sending process: Query S0_IF_BYTE or wait for an interrupt. After each SPI data byte transfer is completed, write to the SPI0_DATA register and write the data to be sent to the FIFO. Or wait for S0_FREE to change from 0 to 1 to continue sending the next byte.\nData receiving process: Query S0_IF_BYTE or wait for an interrupt. After each SPI data byte transfer is completed, read the SPI0_DATA register to get the received data from the FIFO. Query MASK_S0_RFIFO_CNT (that is, S0_R_FIFO1 and S0_R_FIFO0) to get the number of bytes remaining in the FIFO.\n"});index.add({'id':14,'href':'/docs/15-adc/','title':"15. ADC",'content':"15. Analog-to-digital converter ADC 15.1 ADC Introduction The CH559 chip provides 10-bit or 11 optional successive approximation analog-to-digital converters. The converter has 8 analog signal input channels, which can be time-sharing acquisition.\nADC main features:\n Select 10-bit or 11-bit resolution. ADC analog input voltage range: 0 to VDD33. Maximum 1MSPS sampling rate. Supports automatic alternate channel mode for automatic alternate conversion between two input channels. Built-in 2-level FIFO, supporting automatic sampling and DMA.  15.2 ADC Register  Table 15.2.1 ADC related register list\n   NameAddressDescriptionReset value  ADC_EX_SW F7h ADC extended analog switch control register 00h ADC_SETUP F6h ADC setting register 08h ADC_FIFO_H F5h FIFO high byte of ADC (read only) 0xh ADC_FIFO_L F4h FIFO low byte of ADC (read only) xxh ADC_FIFO F4h ADC_FIFO_L and ADC_FIFO_H form a 16-bit SFR 0xxxh ADC_CHANN F3h ADC channel selection register 00h ADC_CTRL F2h ADC control register 00h ADC_STAT F1h ADC status register 04h ADC_CK_SE EFh ADC clock division setting register 10h ADC_DMA_CN EEh DMA Remaining Count Register 00h ADC_DMA_AH EDh DMA current buffer address high byte 0xh ADC_DMA_AL ECh DMA current buffer address low byte xxh ADC_DMA ECh ADC_DMA_AL and ADC_DMA_AH form a 16-bit SFR 0xxxh  DMA current buffer address (ADC_DMA):   BitNameAccessDescriptionReset value  [7:0]ADC_DMA_AHRWThe current high byte of the DMA address, which can be preset to the initial value. It automatically increases after DMA. Only the lower 4 bits are valid. The upper 4 bits are fixed at 0. Only the first 4K of xRAM are supported.0xh [7:0]ADC_DMA_ALRWLow byte of the current DMA address, which can be preset to the initial value. It is automatically increased after DMA. Only the upper 7 bits are valid. The lowest bit is fixed at 0. Only even addresses are supported.xxh  DMA Remaining Count Register (ADC_DMA_CN):   BitNameAccessDescriptionReset value  [7:0]ADC_DMA_CNRWThe current remaining DMA count, which can be preset to the initial value, and is automatically reduced after the DMA operation00h  Clock divider setting register (ADC_CK_SE):   BitNameAccessDescriptionReset value  7bADC_CHK_CLK_SELRWAIN7 level detection delay clock frequency selection, if this bit is 0, low speed 1x clock frequency. If this bit is 1, high speed 4x clock frequency0 [6:0]MASK_ADC_CK_SERWADC clock division factor to set the internal ADC working clock10h  ADC status register (ADC_STAT):   BitNameAccessDescriptionReset value  7 bADC_IF_DMA_END RW DMA complete interrupt flag. A 1 in this bit indicates an interrupt; a 0 in this bit indicates no interrupt. Cleared on write 1 or cleared on ADC_DMA_CN0 6 bADC_IF_FIFO_OV RW This bit is 1 to indicate FIFO overflow interrupt; if this bit is 0, there is no interrupt. Write 1 clear0 5 bADC_IF_AIN7_LOW RW This bit is 1 to indicate that the AIN7 low-level interrupt was detected.0 4 bADC_IF_ACT RW This bit is 1 to indicate an ADC conversion completion interrupt. Write 1 to clear it.0 3 bADC_AIN7_INT R0 This bit is 1 to indicate the delay state of the AIN7 input low level0 2 bADC_CHANN_ID R0 is the current channel identification flag in the automatic alternate channel mode. 0 means AIN0 or AIN6. 1 means AIN1 or AIN4 or AIN70 2 bADC_DATA_OK RO In the manual channel selection mode, the ADC conversion is completed and the result is ready. A 1 indicates that the ADC data is ready and the ADC converter is idle. A 0 indicates that the ADC is in progress and the data is not ready.1 [1:0] MASK_ADC_FIFO_CNT R0 ADC FIFO current count00b  MASK_ADC_FIFO_CNT consists of bADC_FIFO_CNT1 and bADC_FIFO_CNT0, which is used to display the ADC\u0026rsquo;s FIFO count.\n  MASK_ADC_FIFO_CNTDescription  00b FIFO is empty.If the FIFO is read, it will directly return the current ADC result value. 01b 1 data in FIFO 10b FIFO is full, there are 2 data in FIFO 11b unknown error  ADC Control Register (ADC_CTRL):   BitNameAccessDescriptionReset value  7 bADC_SAMPLE RW In the manual sampling mode, it is the sampling control bit. Set it first and then clear it to 0 to generate a high-level pulse to start the ADC once. In the automatic sampling mode, it is the sampling pulse state of automatic sampling.0 6 bADC_SAMP_WIDTH RW Sampling pulse width control bit in auto sampling mode, 0 for 1 ADC clock width; 1 for 2 ADC clock width0 5 bADC_CHANN_MOD1 RW ADC channel mode high0 4 bADC_CHANN_MOD0 RW ADC channel mode low0 [3:0] MASK_ADC_CYCLE RW ADC running cycle number, 0 means manual sampling; non-zero value means setting the running cycle of automatic sampling (counted by ADC clock)0000b  MASK_ADC_CHANN consisting of bADC_CHANN_MOD1 and bADC_CHANN_MOD0 is the ADC channel control mode flag.\n  MASK_ADC_CHANNDescription  00b Manually select channel mode, set ADC_CHANN to select current input channel 01b Auto alternate channel mode, switch between AIN0 and AIN1 automatically 10b Auto Alternate Channel Mode, automatically alternate between AIN6 and AIN4 11b Auto Alternate Channel Mode, automatically alternate between AIN6 and AIN7  ADC channel selection register (ADC_CHANN):   BitNameAccessDescriptionReset value  [7:0]ADC_CHANNRWSelect the current ADC analog input channel, select one from the 8 channels, bits 0~7 correspond to AIN0~AIN7 respectively00h  ADC\u0026rsquo;s FIFO port (ADC_FIFO):   BitNameAccessDescriptionReset value  [7:0]ADC_FIFO_HROADC FIFO high byte, only the lower 4 bits are valid, the upper 4 bits are fixed to 00xh [7:0]ADC_FIFO_LROADC FIFO low bytexxh  ADC setup register (ADC_SETUP):   BitNameAccessDescriptionReset value  7 bADC_DMA_EN RW This bit is 1 to enable the DMA and DMA interrupts of the ADC. 0 to disable the enable0 6 bADC_IE_FIFO_OV RW This bit is 1 to enable the FIFO overflow interrupt. This bit is 0 to disable the enable0 5 bADC_IE_AIN7_LOW RW This bit is 1 to enable detection of AIN7 low-level interrupt0 4 bADC_IE_ACT RW This bit is 1 to enable the ADC conversion completion interrupt. This bit is 0 to disable the enable0 3 bADC_CLOCK RO Current level of the internal ADC clock signal0 2 bADC_POWER_EN RW ADC power control bit of the sampling conversion module. This bit is 0 to turn off the power of the ADC module and enter the sleep state. A bit of 1 to turn on0 1 bADC_EXT_SW_EN RW Power control bit of the extended analog switch module. This bit is 0 to disable the extended analog switch module. 1 to enable the bit.0 0 bADC_AIN7_CHK_EN RW Detect the power control bit of AIN7 low-level module. This bit is 0 to disable detection of AIN7 low-level module. 1 to enable0  ADC extended analog switch control register (ADC_EX_SW):   BitNameAccessDescriptionReset value  7 bADC_SW_AIN7_H RW AIN7 channel internal analog switch connection control, this bit is 1 internally connects AIN7 to VDD33. This bit is 0 to disconnect AIN7 from VDD330 6 bADC_SW_AIN6_L RW AIN6 channel internal analog switch connection control, this bit is 1 internally connects AIN6 to GND. This bit is 0 to disconnect AIN6 from GND0 5 bADC_SW_AIN5_H RW AIN5 channel internal analog switch connection control, this bit is 1 internally connects AIN5 to VDD33. This bit is 0 to disconnect AIN5 and VDD330 4 bADC_SW_AIN4_L RW AIN4 channel internal analog switch connection control, this bit is 1 internally connects AIN4 to GND. This bit is 0 to disconnect AIN4 from GND0 3 bADC_EXT_SW_SEL RW On-resistance value selection bit of the internal analog switch. This bit is 0 to select high resistance, about 800Ω. This bit is 1 to select low resistance, about 300Ω0 2 bADC_RESOLUTION RW ADC resolution selection bit, this bit is 0 to select 10-bit resolution. This bit is 1 to select 11-bit resolution0 1 bADC_AIN7_DLY1 RW Delay control bit for detecting AIN7 low level 10 0 bADC_AIN7_DLY0 RW Delay control bit for detecting AIN7 low level 00  bADC_AIN7_DLY1 and bADC_AIN7_DLY0 form MASK_ADC_AIN7_DLY, which is used to select the delay after detecting the level change of AIN7: 00 is no delay, 01 is the longest delay, 10 is the longer delay, and 11 is the shorter delay.\n15.3 ADC Functions ADC sampling mode configuration steps:\n Set the bADC_POWER_EN bit in the ADC setting register ADC_SETUP to 1 to enable the ADC module. Set the clock divider setting register ADC_CK_SE, select the clock frequency, the highest frequency is 12MHz, and it is recommended not to be lower than 1MHz. Clear the existing data in the FIFO. If you need to use interrupt or DMA, then make the relevant settings here. For the automatic sampling mode, the ADC channel selection register ADC_CHANN should be set first. Set bADC_SAMPLE and MASK_ADC_CYCLE in the ADC control register ADC_CTRL.If MASK_ADC_CYCLE is set to 0, it is a manual sampling mode.If MASK_ADC_CYCLE is set to a non-zero value, it is an automatic sampling mode.At this time, MASK_ADC_CYCLE is a continuous and automatic sampling. Clock cycle. For the manual sampling mode, set the ADC channel selection register ADC_CHANN to select the ADC analog signal input channel. If it is in manual sampling mode, you need to set the bADC_SAMPLE bit to 1 and clear it after delaying at least one ADC clock cycle to complete an analog signal sampling and start an ADC conversion. Wait for the bADC_IF_ACT bit in the ADC status register ADC_STAT to be 1, indicating that the ADC conversion is complete, and the result data can be read through the ADC_FIFO. Or read MASK_ADC_FIFO_CNT of ADC status register ADC_STAT to get the FIFO count, and then read some data through ADC_FIFO. It is recommended to discard the first ADC result data, because there may be incomplete sampling. For DMA steps: Set ADC_DMA as the start address value of the user-defined data buffer, set ADC_DMA_CN as the user-defined DMA remaining count, and set the bADC_DMA_EN bit in ADC_SETUP to 1 to enable the DMA function. There are 12 bits of ADC result data, among which bits 0 ~ 10 are ADC values, bits 11 are flag bits, bits 12 ~ 15 are always 0. For manual channel selection mode, bit 11 is always 0; for automatic alternate channel mode, bit 11 indicates the channel identification flag of the ADC value, refer to bADC_CHANN_ID description.  "});index.add({'id':15,'href':'/docs/16-usb/','title':"16. USB",'content':"16.USB Controller 16.1 Introduction to USB Controller The CH559 has a built-in USB controller and dual USB transceivers. The features are as follows:\n Supports USB Host and USB Device functions Supports USB 2.0 full speed 12Mbps or low speed 1.5Mbps Support USB control transfers, bulk transfers, interrupt transfers, iso transfers Provide dual-port Root-HUB in USB host mode, can manage two USB devices at the same time Support data packets up to 64 bytes, built-in FIFO, support interrupts and DMA  The USB related registers of the CH559 are divided into 3 groups, and some of the registers are multiplexed between host and device mode.\n USB global register USB device controller register USB host controller register  16.2 Global Register Table 16.2.1 USB Global Register\r\r\rNameAddressDescriptionReset Value\r\rUSB_RX_LEND1hUSB Receive Length Register (RO) 0xxx\u0026nbsp;xxxxb\rUSB_INT_FGD8hUSB Interrupt Flag Register 0010 0000b\rUSB_INT_STD9hUSB Interrupt Status Register (RO) 00xx xxxxb\rUSB_MIS_STDAhUSB Miscellaneous Status Register (RO) xx10 1000b\rUSB_INT_ENE1hUSB interrupt enable register0000 0000b USB_CTRL E2hUSB control register0000 0110b\rUSB_DEV_ADE3hUSB device address register0000 0000b\rUSB_DMA_AHE7hDMA current buffer address high byte (RO) 000x xxxxb\rUSB_DMA_ALE6hDMA Low byte of current buffer address (RO) xxxx xxx0b\rUSB_DMA E6hUSB_DMA_AL and USB_DMA_AH form a sfr16 xxxxh\r\rUSB Receive Length Register (USB_RX_LEN): \r\rBitNameAccessDescriptionReset value\r\r[7:0]bUSB_RX_LENROnumber of bytes received by the current USB endpoint xxh\r\rUSB Interrupt Flag Register (USB_INT_FG bit addressable): \r\rBit Name Access Description Reset value\r\r7U_IS_NAKROUSB Device mode:\na 1 indicates that a NAK response was received during the current USB transfer; a 0 indicates that a non-NAK response was received0\r6U_TOG_OKROThe current USB transfer DATA0/1 toggle flag match status. If set to is 1 the toggle is as expected and the data are valid. If this bit is 0 data are out of sync, data may be invalid.0\r5U_SIE_FREEROIdle status bit of the USB protocol processor. This bit is 0 to indicate busy and USB transfer is in progress. This bit is 1 to indicate USB idle.1\r4UIF_FIFO_OVRWUSB FIFO overflow interrupt flag bit. A 1 in this bit indicates a FIFO overflow has occured. Automatically cleared by direct bit access or writing 1 to the register 0 \r3UIF_HST_SOFRWUSB Host mode:\nSOF timer interrupt flag bit. This bit is 1 to indicate a SOF interrupt. This interrupt is triggered by the completion of a SOF packet transfer. Automatically cleared by direct bit access or writing 1 to the register 0 \r2UIF_SUSPENDRWUSB bus suspend or wake event interrupt flag bit. This bit is 1 to indicate an interrupt. This interrupt is triggered by a USB suspend or wake event. Automatically cleared by direct bit access or writing 1 to the register 0 \r1UIF_TRANSFERRWUSB transfer complete interrupt flag bit. This bit is 1 to indicate that there is an interrupt. The interrupt is reset by 0. A USB transfer completion trigger. Automatically cleared by direct bit access or writing 1 to the register 0 \r0UIF_DETECT\nUIF_BUS_RSTRW\rUSB Host mode:\nset to 1 by hardware when a connection change is detectet, automatically cleared by direct bit access or writing 1 to the register.\nUSB Device mode:\nset to 1 by hardware when a USB device reset is recieved, automatically cleared by direct bit access or writing 1 to the register.\r0\r\rUSB Interrupt Status Register(USB_INT_ST): \r\rBit Name Access Description Reset value\r\r7bUIS_IS_NAKROUSB Device mode:\nthis bit is 1 to indicate that a NAK busy response was received during the current USB transfer. Same as U_IS_NAK 0\r6bUIS_TOG_OKROThe current USB transfer DATA0 / 1 synchronization flag match status. This bit is 1 to indicate synchronization; this bit to 0 indicates not to synchronize. Same as U_TOG_OK 0\r[5:4]bUIS_TOKENROTransaction PID:00: indicates an OUT packet; 01: indicates a SOF packet;10: indicates an IN packet;11: indicates a SETUP packet.xxb\r[3:0]MASK_UIS_ENDP\nMASK_UIS_H_RESRO\rUSB Device mode:\nindicates the endpoint number of the current USB transfer 0000b=EP0 1111=EP15\nUSB HOST mode:\nPID ID of of the current USB transfer 0000b=no reponse or timeout other values represend the response PID\rxxxxb\r\rUSB Miscellaneous Status Register (USB_MIS_ST): \r\rBit Name Access Description Reset value\r\r7bUMS_SOF_PRESROUSB Host mode:\nThe SOF packet indicates the status bit. This bit is 1 to indicate that a SOF packet will be sent. At this time, any other USB data packets will be automatically postponed. x \r6bUMS_SOF_ACT ROUSB Host mode:\nSOF packet transfer status, this bit is 1 to indicate that a SOF packet is being sent; this bit to 0 indicates that the transmission is complete or idle x\r5bUMS_SIE_FREEROIdle status bit of the USB protocol processor. This bit is 0 to indicate busy and USB transmission is in progress. This bit is 1 to indicate that USB is idle. Same as U_SIE_FREE 1 4bUMS_R_FIFO_RDYROUSB receive FIFO data ready status bit, this bit is 0 means the receive FIFO is empty; this bit is 1 means the receive FIFO is not empty 0\r3bUMS_BUS_RESETROUSB bus reset status bit, this bit is 0 means there is no USB bus reset at present; this bit is 1 means the USB bus is currently reset 1 2bUMS_SUSPENDROUSB suspend status bit, this bit is 0 to indicate that there is currently USB activity; this bit is 1 to indicate that there has been no USB activity for a period of time, requesting suspension 0 \r1bUMS_H1_ATTACHROUSB host mode:\nthe USB device connection status bit of the HUB1 port. A 1 in this bit indicates that the USB device is connected to HUB1. 0 \r0bUMS_H0_ATTACHROUSB host mode:\nthe USB device connection status bit of the HUB0 port. This bit is 1 to indicate that the HUB0 is connected to a USB device. 0 \r\rUSB interrupt enable register (USB_INT_EN): \r\rBit Name Access Description Reset value\r\r7bUIE_DEV_SOFRWUSB Host mode:\nThis bit is 1 to enable USB device mode to receive SOF packet interrupt; 0 is disabled0 6bUIE_DEV_NAKRWUSB Device mode:\nThis bit is 1 to enable to receive NAK interrupt; 0 is disabled0 5ReservedROreserved 0\r4bUIE_FIFO_OVRWThis bit is 1 to enable FIFO overflow interrupt; this bit is 0 to disable0\r3bUIE_HST_SOFRWThis bit is 1 to enable USB host mode SOF timer interrupt; 0 is disabled0\r2bUIE_SUSPENDRWThis bit is 1 Enable the USB bus suspend or wake event interrupt; 0 disables0\r1bUIE_TRANSFERRWThis bit is 1 to enable the USB transfer completion interrupt; this bit is 0 to disable0\r0bUIE_DETECT\nbUIE_BUS_RSTRW\rUSB Host Mode:\nSet to 1 to enable USB device connect or disconnect event interrupt. If set to 0 no interrupts on status changes will be generated\nUSB Device Mode:\nSet to 1 to enable USB Reset event interrupt. If set to 0 no interrupts on USB Reset events will be generated\r0\r\rUSB Control Register (USB_CTRL): \r\rBitName Access Description Reset value\r\r7bUC_HOST_MODERWUSB working mode selection bit, this bit is 0 to select USB device mode (DEVICE); this bit is 1 to select USB host mode (HOST)0\r6bUC_LOW_SPEEDRWUSB bus signal transmission rate selection bit, this bit is 0 to select full speed 12Mbps; this bit is 1 to select low speed 1.5Mbps0\r5bUC_DEV_PU_ENRWUSB device enable and internal pull-up resistor control bit in USB device mode. This bit is 1 to enable USB device transmission and enable internal pull-up resistor0\r[5:4]bUC_SYS_CTRLRW\rDevicemode:(bUC_HOST_MODE=0)\r00b: Disable USB device function, no pull-up resistor\r01b: Enable USB device function, no pull-up resitor use external pull-up\r10b: Enable USB device function, internal pull-up on\r11b: Enable USB device function, internal pull-up weak\rHostmode:(bUC_HOST_MODE=1)\r00b: normal working state 01b: force DP/DM to output SE0 state\r10b: force DP/DM to output J state 11b: force DP/DM to output K state/wake up\r00b\r3bUC_INT_BUSY RWUSB transfer completion interrupt flag is automatically suspended before the interrupt flag is not cleared. If this bit is 1, it is automatically suspended before the interrupt flag UIF_TRANSFER is not cleared. It will automatically answer the busy NAK for the device mode, and automatically suspend the subsequent transmission for the host mode; Bit 0 does not pause0\r2bUC_RESET_SIERWUSB protocol processor software reset control bit. When this bit is 1, the USB protocol processor is reset forcibly. It needs to be cleared by software.1\r1bUC_CLR_ALL RWThis bit is 1 to clear the USB interrupt flag and FIFO, which needs to be cleared by software1\r0bUC_DMA_EN RWThis bit is 1 to enable the USB DMA and DMA interrupts; 0 to disable the enable0\r\rUSB device address register (USB_DEV_AD): \r\rBitName AccessDescriptionReset value\r\r7bUDA_GP_BITRWUSB general-purpose flag bit: user-defined, can be cleared or set by software0\r[6:0]MASK_USB_ADDRRWIn the host mode, it is the address of the currently operating USB device; in the device mode, it is the address of the USB device00h\r\r16.3 Device Registers In USB device mode The CH559 provides five groups of two-way endpoints 0, 1, 2, 3, and 4. The maximum packet size for each endpoint is 64 bytes. Endpoint 0 is the default endpoint used for control (SETUP) tranfers, sending and receiving uses the same 64-byte data buffer.\nEndpoint 1, Endpoint 2, Endpoint 3 each includes a sending endpoint IN and a receiving endpoint OUT. Each Endpoint can have its own independent 64-byte buffer or double 64-byte data buffer, which supports control, bulk, interrupt and iso transfers. Endpoint 4 is a bit different since it has no own DMA control but shares DMA and with Endpoint 0. It supports control, bulk, interrupt and iso transfers.\nEach pair of endpoints has its own control register UEPn_CTRL and its own transfer size register UEPn_T_LEN (n = 0/1/2/3/4), which is used to set the toggle bit of the endpoint in response to OUT transaction, IN transaction and the sending data Length, etc.\nThe pull-up resistor of the USB bus, as necessary for a USB device, can be set by software at any time. When bUC_DEV_PU_EN is set in the USB control register USB_CTRL, the CH559 internally connects a 1k5 pullup to the DP pin or DM pin according to the settings of bUD_LOW_SPEED and thus enable the USB device function as low or full speed device.\nIn case of any USB event such as USB bus reset, USB bus suspend, wake-up, USB Setup or USB transfer event, the USB protocol processor will set the corresponding interrupt flag and generates an interrupt request. The application has to query the interrupt flag register USB_INT_FG to determine the event, or if USB interrupt mode is used take the neccessary actions in an USB interrupt service routine.\nThere are 3 major events which should be handled by the firmware:\n UIF_BUS_RST: issued by the host to reset the usb device UIF_SUSPEND: issued by the host to put the usb device into sleep mode UIF_TRANSFER: data transfers to the verious endpoints  For UIF_TRANSFER the USB interrupt status register USB_INT_ST provides information about type of transfer in the bUIS_TOKEN field and endpoint number in the MASK_UIS_ENDP field. Both fields have to be evaluated to perform the next action on the bus. If the toggle bit bUEP_R_TOG of the OUT transaction for the endpoint is set in advance, U_TOG_OK or bUIS_TOG_OK can be used to check whether toggle bit of the actual received data packet matches the expected toogle bit of the endpoint. If the bit is set data packe is valid. If not the data the data should be discarded.\nEach time the USB send or receive interrupt is processed, the toggle bit of the corresponding endpoint should be modified correctly to synchronize the next data packet sent and check whether the next received data packet is synchronized. In addition, by setting bUEP_AUTO_TOG, the toggle bit will change automatically after each successful transmission or successful reception. The data to be sent by each endpoint is in its own buffer, and the size of the data to be sent is independently set in UEPn_T_LEN. The data received by each endpoint is in its own buffer, but the length of the received data is all in the USB receive length Register USB_RX_LEN, which can be distinguished according to the current endpoint number when USB receive interrupt\nTable 16.3.1 USB Device Related Register List \r\rNameAddressDescriptionReset Value\r\rUEP1_CTRL D2hEndpoint 1 Control Register0000\u0026nbsp;0000b\rUEP1_T_LEND3hEndpoint 1 Send Length Register 0xxx xxxxb\rUEP2_CTRLD4hEndpoint 2 Control Register 0000 0000b\rUEP2_T_LEND5hEndpoint 2 Send Length Register0000 0000b\rUEP3_CTRLD6hEndpoint 3 control register0000 0000b\rUEP3_T_LEND7hEndpoint 3 Send Length Register0xxx xxxxb\rUEP0_CTRLDChEndpoint 0 Control Register0000 0000b\rUEP0_T_LENDDhEndpoint 0 Send Length Register0xxx xxxxb\rUEP4_CTRLDEhEndpoint 4 Control Register0000 0000b\rUEP4_T_LENDFhEndpoint 4 Send Length Register0xxx xxxxb\rUDEVCTRLE4hDevice Control Register0100 x000b\rUEP4_1_MOD2446hEndpoint 1, 4 mode control register0000 0000b\rUEP2_3_MOD2447hEndpoint 2, 3 mode control register0000 0000b\rUEP0_DMA_H2448hEndpoint 0/4 DMA buffer start high byte000x xxxxb\rUEP0_DMA_L2449hEndpoint 0/4 DMA buffer start low Bytexxxx xxx0b\rUEP1_DMA_H244AhEndpoint 1 DMA start high Byte000x xxxxb\rUEP1_DMA_L244BhEndpoint 1 DMA start low Bytexxxx xxxxb\rUEP2_DMA_H244ChEndpoint 2 buffer start address high byte000x xxxxb\rUEP2_DMA_L244DhEndpoint 2 buffer start address low bytexxxx xxx0b\rUEP3_DMA_H244EhEndpoint 3 Buffer Start Address High Byte000x xxxxb\rUEP3_DMA_L244FhEndpoint 3 Buffer Start Address Low Bytexxxx xxx0b\rpUEP*254*hafter bXIR_XSFR is set, this names can be used to address the above xSFR as pdata, which is faster than xdata type addressing\r\rEndpoint n Control Register (UEPn_CTRL): \r\rBitName Access Description Reset value\r\r7bUEP_R_TOGRWSynchronous trigger bit expected by the receiver of USB endpoint n (handling SETUP / OUT transactions). This bit is 0 for DATA0; 1 for DATA10\r6bUEP_T_TOGRWSynchronous trigger bit prepared by the USB endpoint n's transmitter (processing IN transaction). This bit is 0 to send DATA0; 1 to send DATA10\r5ReservedROReserved0\r[3:2]bUEP_R_RESRW\rHandshake for a SETUP or OUT ransfers:\r00: send a ACK handshake to the host(ready)\r01: send nothing timeout to the host(used on iso transfers)\r10: send a NAK handshake to the host(busy)\r11: send a STALL handshake to the host(error)\r00b\r[1:0]bUEP_T_RESRW\rHandshake recieved for IN Transfers:\r00: recived a ACK handshake from the host(ready)\r01: recived no handshake from the host(timeout or iso)\r10: recived a NAK handshake from the host(busy)\r11: recived a STALL handshake from the host(error)\r00b\r\rEndpoint n Transmit Length Register (UEPn_T_LEN): \r\rBitName Access Description Reset value\r\r[7:0]bUEPn_T_LEN\nbUEP2_T_LENRWSet the number of data bytes to be sent by USB endpoint n (n = 0/1/3/4) bUEP2_T_LEN Set the number of data bytes to be sent by USB endpoint 2xxh\n00h\r\rUSB Device Physical Port Control Register (UDEV_CTRL): \r\rBitName Access Description Reset value\r\r7ROReserved0\r6bUD_RECV_DISRWUSB device physical port receiver disable bit, this bit is 1 to disable the receiver and there is no static power; this bit is 0 to enable the receiver and generate static power1\r5bUD_DP_PD_DISRWUSB device port DP pin internal pull-down resistor disable bit, this bit is 1 to disable internal pull-down resistor; this bit is 0 to enable DP internal pull-down resistor0\r4bUD_DM_PD_DISRWUSB device port DM pin internal pull-down resistor disable bit, this bit is 1 to disable internal pull-down resistor; this bit is 0 to enable DM internal pull-down resistor0\r3bUD_DIFF_IN R0Current differential input status between DP and DM pinsx\r2bUD_LOW_SPEEDRWUSB device physical port low speed mode enable bit, this bit is 1 to select 1.5Mbps low speed mode; this bit is 0 to select 12Mbps full speed mode0\r1bUD_GP_BITRWUSB device mode general flag: user can define it by himself, it can be cleared or set by software0\r0bUD_PORT_ENRWUSB device physical port enable bit, this bit is 1 to enable the physical port; this bit is 0 to disable the physical port0\r\rUSB endpoint 1, 4 mode control register (UEP4_1_MOD): \r\rBitName Access Description Reset value\r\r7bUEP1_RX_ENRWThis bit is 0 to disable endpoint 1 reception; 1 to enable endpoint 1 reception (OUT)0\r6bUEP1_TX_ENRWThis bit is 0 to disable endpoint 1 send; enable endpoint 1 send (IN) for 10\r5reserved ROreserve0\r4bUEP1_BUF_MODRWendpoint 1 data buffer mode control bit0\r3bUEP4_RX_ENROThis bit is 0 to disable endpoint 4 reception; enable 1 to enable endpoint 4 reception (OUT)0\r2bUEP4_TX_ENRWThis bit is 0 to disable endpoint 4 transmission; 1 to enable endpoint 4 transmission (IN)0\r[1:0]ReservedROreserved00b\r\rThe combination of bUEP4_RX_EN and bUEP4_TX_EN controls the data buffering of USB endpoints 0 and 4 Zone mode, refer to the table below.\nTable 16.3.2 Endpoints 0 and 4 buffer mode\r\r\rbUEP4_RX_ENbUEP4_TX_ENStructure description: starting from UEP0_DMA from low to high\r\r00Endpoint 0 single 64-byte transmit and receive shared buffers (IN and OUT)\r10Endpoint 0 single 64 Bytes send and receive common buffer; Endpoint 4 single 64-byte receive buffer (OUT)\r01Endpoint 0 and single send 64-byte shared buffer; Endpoint 4 single 64-byte send buffer (IN)\r11Endpoint 0 single 64-byte transmit and receive buffer; Endpoint 4 single 64-byte receive buffer (OUT); Endpoint 4 single 64-byte send buffer (IN).\nThe entire 192 bytes are arranged as follows: UEP0_DMA + 0 Address: Endpoint 0 is shared for sending and receiving; UEP0_DMA + 64 Address: Endpoint 4 is receiving; UEP0_DMA + 128 Address: Endpoint 4 is sending\r\rUSB endpoint 2, 3 mode control register (UEP2_3_MOD): \r\rBitName Access Description Reset value\r\r7bUEP3_RX_ENRWThis bit is 0 to disable endpoint 3 reception; 1 to enable endpoint 3 reception (OUT)0\r6bUEP3_TX_ENRWThis bit is 0 to disable endpoint 3 transmission; enable 1 to enable endpoint 3 transmission (IN )0\r5Reserved ROReserved0\r4bUEP3_BUF_MODRWEndpoint 3 Data Buffer Mode Control Bit0\r3bUEP2_RX_ENROThis bit is 0 to disable endpoint 2 reception; 1 to enable endpoint 2 reception (OUT)0\r2bUEP2_TX_ENRWThis bit is 0 to disable Endpoint 2 Send; Enable Endpoint 2 Send (IN) for 10\r1ReservedROReserved0\r0bUEP2_BUF_MODRWEndpoint 2 Data Buffer Mode Control Bit0\r\rControlled by bUEPn_RX_EN and bUEPn_TX_EN and bUEPn_BUF_MOD (n = 1/2/3) respectively. For the data buffer mode of USB endpoints 1, 2, and 3, refer to the following table. Among the dual 64-byte buffer modes, the first 64-byte buffer is selected according to bUEP_*_TOG = 0 during USB data transfer, and the last 64-byte buffer is selected according to bUEP_*_TOG = 1 to realize automatic switching.\nTable 16.3.3 Endpoint n buffer mode (n = 1/2/3) \r\r\rbUEPn_RX_ENbUEPn_TX_ENbUEPn_BUF_MODStructure description: starting from UEPn_DMA from low to high/th\r\r00xThe endpoint is disabled and the UEPn_DMA buffer is not used\r100Single 64-byte receive buffer (OUT)\r101Double 64-byte receive buffer, selected by bUEP_R_TOG 010Single 64-byte receive buffer (IN) 011Double 64-byte receive buffer, pass bUEP_T_TOG selection 110single 64-byte receive buffer; single 64-byte transmit buffer\r111Double 64-byte receive buffer, selected by bUEP_R_TOG; double 64-byte send buffer, selected by bUEP_T_TOG. All 256 bytes are arranged as follows: UEPn_DMA + 0 address: endpoint receives when bUEP_R_TOG = 0; UEPn_DMA + 64 address: endpoint receives when bUEP_R_TOG = 1; UEPn_DMA + 128 address: endpoint sends when bUEP_T_TOG = 0; UEPn_DMA + 192 address: bUEP_T_TOG = 1:00 sent by endpoint\r\rUSB Endpoint n Buffer Start Address (UEPn_DMA) (n = 0/1/2/3): \r\rBitName Access Description Reset value\r\r[7:0]UEPn_DMA_HRWEndpoint n buffer start address high byte, only the lower 5 bits are valid, the upper 3 bits are fixed to 0xxh\r[7:0]UEPn_DMA_LRWEndpoint n buffer start address low byte, only the upper 7 bits are valid, the lowest bit is fixed to 0, only even address is supportedxxh\r\rNote: The length of the buffer to receive data is = min(maximum packet length that may be received + 2 bytes, 64 bytes)\n16.4 Host Register In USB host mode The CH559 provides a set of bidirectional host endpoints, including a sending endpoint OUT and a receiving endpoint IN. The maximum data packet length is 64 bytes. It supports control transfers, bulk transfers, interrupt transfers and iso transfers. Every USB transaction initiated by the host endpoint always sets the interrupt flag UIF_TRANSFER automatically after processing is complete. The application program can directly query or analyze and analyze the interrupt flag register USB_INT_FG in the USB interrupt service routine, and perform corresponding processing according to each interrupt flag; and, if UIF_TRANSFER is valid, then it needs to continue to analyze the USB interrupt status register USB_INT_ST. The response PID identifier MASK_UIS_H_RES of the transmission transaction is processed accordingly. If the synchronization trigger bit bUH_R_TOG of the IN transaction of the host receiving endpoint is set in advance, you can use U_TOG_OK or bUIS_TOG_OK determines whether the synchronization trigger bit of the currently received data packet matches the synchronization trigger bit of the host receiving endpoint. If the data is synchronized, the data is valid; if the data is not synchronized, the data should be discarded. Each time the USB send or receive interrupt is processed, the synchronization trigger bit of the corresponding host endpoint should be modified correctly to synchronize the next data packet sent and detect whether the next received data packet is synchronized; in addition, by setting bUEP_AUTO_TOG It can be realized that the corresponding synchronization trigger bit is automatically flipped after sending successfully or receiving successfully.\nThe USB host token setting register UH_EP_PID is shared with the the USB endpoint 1 control register in the USB device mode. It is used to set the endpoint number of the target device to be operated and the token PID packet identifier of the USB transfer transaction. The data corresponding to the SETUP token and the OUT token are provided by the host sending endpoint. The data to be sent is in the UH_TX_DMA buffer and the length of the data to be sent is set in UH_TX_LEN; the data corresponding to the IN token is returned by the target device to the host Receiving endpoint, the received data is stored in the UH_RX_DMA buffer, and the length of the received data is stored in USB_RX_LEN.\nTable 16.4.1 USB host related register list\r\r\rName Address Description Reset Value\r\rUH_SETUP D2hUSB host auxiliary setting register 0000\u0026nbsp;0000b\rUH_RX_CTRLD4hUSB host receiving endpoint control register 0000 0000b UH_EP_PID D5hUSB host token setting register 0000 0000b\rUH_TX_CTRLD6hUSB host sending endpoint control Register 0000 0000b\rUH_TX_LEN D7hUSB host transmit length register 0xxx xxxxb\rUSB_HUB_STDBhUSB host HUB port status register (read only)0000 0000b\rUHUB0_CTRLE4hUSB host HUB0 port control register 0100 x000b\rUHUB1_CTRLE5hUSB host HUB1 port control register 1100 x000b\rUH_EP_MOD 2447hEndpoint mode control register 0000 0000b UH_RX_DMA_H244ChUSB host receive buffer start address high byte 000x xxxxb\rUH_RX_DMA_L244DhUSB host receive buffer start address low byte xxxx xxx0b\rUH_RX_DMA 244ChUH_RX_DMA_L and UH_RX_DMA_H form a 16-bit SFRxxxxh\rUH_TX_DMA_H244EhUSB host send buffer start address high byte 000x xxxxb\rUH_TX_DMA_L244FhUSB host send buffer start address low byte xxxx xxx0b\rUH_TX_DMA 244EhUH_TX_DMA_L and UH_TX_DMA_H form a 16-bit SFRxxxxh\rpUH_* 254*hAfter bXIR_XSFR is set, this names are used to address the above xSFR as a pdata type, which is faster than xdata type addressing\r\rUSB host auxiliary setup register (UH_SETUP): \r\rBitName Access Description Reset value\r\r7bUH_PRE_PID_ENRWLow-speed preamble packet PRE PID enable bit, this bit is 1 to enable the USB host to communicate with the low-speed USB device through an external HUB; 0 to disable the low-speed preamble packet, there must be no HUB between the USB host and the low-speed USB device0\r6bUH_SOF_ENRWAutomatically generate SOF packet enable bit. This bit is 1. The SOF packet is automatically generated by the USB host; 0 is not generated automatically, but it can be generated manually.0\r[5:0]ReservedROreserved00h\r\rUSB Host Receive Endpoint Control Register (UH_RX_CTRL): \r\rBitName Access Description Reset value\r\r7bUH_R_TOGRWThe expected synchronization trigger bit for the USB host receiver (handling IN transactions). This bit is 0 for DATA0 and 1 for DATA1.0\r[6:5]ReservedROreserved00b\r4bUH_R_AUTO_TOGRWAutomatically flip bUH_R_TOG control bit. This bit is 1 to automatically flip the bUH_R_TOG flag after the USB host receives successfully; 0 to not flip automatically, but can be manually switched.0\r3ReservedROreserved0\r2bUH_R_RESRWUSB host receiver response control bit for IN transaction, 0 means ACK or ready; 1 means no response, used for real-time / synchronous transfer with non-endpoint 0 of the target device0\r[1:0]ReservedROreserved00b\r\rUSB host token setting register (UH_EP_PID): \r\rBitName Access Description Reset value\r\r[7:4]MASK_UH_TOKENRWSet the token PID packet ID of this USB transfer transaction0000b\r[3:0]MASK_UH_ENDP RWSet the target to be operated this time Device endpoint number0000b\r\rUSB Host Send Endpoint Control Register (UH_TX_CTRL): \r\rBitName Access Description Reset value\r\r7Reserved ROReserved0\r6bUH_T_TOGRWSynchronous trigger bit prepared by the USB host transmitter (handling SETUP / OUT transactions). This bit is 0 to send DATA0; 1 to send DATA10\r5ReservedROReserved0\r4bUH_T_AUTO_TOGRWAutomatically flip bUH_T_TOG control bit, this bit is 1 to automatically flip the bUH_T_TOG flag after the USB host sends successfully; 0 to not flip automatically, but can be manually switched0\r[3:1]ReservedROreserved000b\r0bUH_T_RESRWUSB host transmitter response control bit for SETUP / OUT transaction, 0 means to expect ACK or ready; 1 means no response, used for real-time / synchronous transmission with non-endpoint 0 of the target device0\r\rUSB Host Send Length Register (UH_TX_LEN): \r\rBitName Access Description Reset value\r\r[7:0]UH_TX_LENRWSets the number of data bytes to be sent by the USB host send endpointxxh\r\rUSB host HUB port status register (USB_HUB_ST): \r\rBitName Access Description Reset value\r\r7bUHS_H1_ATTACHROThe USB device connection status bit of the HUB1 port. A 1 in this bit indicates that a USB device is connected to HUB1; a 0 in this bit indicates no. Same as bUMS_H1_ATTACH0\r6bUHS_HM_LEVEL RORecord the state of the HM pin when the USB device is just connected to the HUB1 port. 0 means low level; 1 means high level. Used to determine full speed or low speed0\r5bUHS_HP_PIN ROCurrent HP pin status, 0 for low level; 1 for high level0\r4bUHS_HM_PIN ROCurrent HM pin status, 0 for low level; 1 for high level0\r3bUHS_H0_ATTACHROThe USB device connection status bit of the HUB0 port. A 1 in this bit indicates that a USB device is connected to HUB0; a 0 in this bit indicates no. Same as bUMS_H0_ATTACH0\r2bUHS_DM_LEVEL RORecord the state of the DM pin when the USB device is just connected to the HUB0 port. 0 means low level; 1 means high level. Used to determine full speed or low speed0\r1bUHS_DP_PIN ROCurrent DP pin status, 0 for low level; 1 for high level0\r0bUHS_DM_PIN ROCurrent DM pin status, 0 for low level; 1 for high level0\r\rUSB host HUBn port control register (UHUBn_CTRL) (n = 0, 1): \r\rBitName Access Description Reset value\r\r7bUH1_DISABLE RWFor UHUB1_CTRL is the USB host HUB1 port pin disable bit, this bit is 1 to disable the HP / HM pin, releasing P5.5 / P5.4 will be used for other functions; this bit is 0 to enable P5.5 / P5.4 Used as HP / HM for HUB1 port1\r6bUH_RECV_DIS RWUSB host HUBn port receiver disable bit, this bit is 1 to disable the receiver and there is no static power consumption; this bit is 0 to enable the receiver and generate static power consumption1\r5bUH_DP_PD_DISRWUSB host HUBn port DP / HP pin internal pull-down resistor disable bit, this bit is 1 to disable internal pull-down resistor; this bit is 0 to enable internal pull-down resistor0\r4bUH_DM_PD_DISRWUSB host HUBn port DM / HM pin internal pull-down resistor disable bit, this bit is 1 to disable internal pull-down resistor; this bit is 0 to enable internal pull-down resistor0\r3bUH_DIFF_IN R0For UHUB0_CTRL is the current differential input state between the DP and DM pins For UHUB1_CTRL is the current differential input state between the HP and HM pinsx\r2bUH_LOW_SPEEDRWUSB host HUBn port low speed mode enable bit, this bit is 1 to select 1.5Mbps low speed mode; this bit is 0 to select 12Mbps full speed mode0\r1bUH_BUS_RESETRWUSB host HUBn port bus reset control bit, this bit is 1 to force the HUBn port to output USB bus reset; this bit is 0 to end the output0\r0bUH_PORT_EN RWUSB host HUBn port enable bit, this bit is 0 to disable the HUBn port; this bit is 1 to enable the HUBn port. This bit is automatically cleared when the USB device is disconnected0\r\rUSB Host Endpoint Mode Control Register (UH_EP_MOD): \r\rBitName Access Description Reset value\r\r7ReservedROReserved0\r6bUH_EP_TX_ENRWThis bit is 0 to disable the USB host from sending endpoints to send data; this bit is 1 to enable the USB host to send endpoints to send data (SETUP / OUT)0\r5ReservedROreserved0\r4bUH_EP_TBUF_MODRWUSB host transmit endpoint data buffer mode control bit0\r3bUH_EP_RX_ENROThis bit is 0 to disable the USB host receiving endpoint from receiving data; this bit is 1 to enable the USB host receiving endpoint to receive data (IN)0\r[2:1]ReservedROreserved00b\r0bUH_EP_RBUF_MODRWUSB host receive endpoint data buffer mode control bit0\r\rControlled by the combination of bUH_EP_TX_EN and bUH_EP_TBUF_MOD, the USB host sends endpoint data buffer mode, refer to the table below.\nTable 16.4.2 Host transmit buffer mode \r\rbUH_EP_TX_ENbUH_EP_TBUF_MODStructure description: Start with UH_TX_DMA\r\r0xEndpoint is disabled, UH_TX_DMA buffer is not used\r10Single 64-byte transmit buffer (SETUP / OUT)\r11Double 64-byte transmit buffer, selected by bUH_T_TOG:\nWhen bUH_T_TOG = 0, the first 64-byte buffer is selected;\nwhen bUH_T_TOG = 1, the latter 64-byte buffer is selected\r\rby the combination of bUH_EP_RX_EN and bUH_EP_RBUF_MOD to control the USB host receiving endpoint data buffer Mode, refer to the table below.\nTable 16.4.3 Host receive buffer mode \r\rbUH_EP_RX_ENbUH_EP_RBUF_MODStructure description: Start with UH_RX_DMA\r\r0xEndpoint is disabled, UH_RX_DMA buffer is not used\r10Single 64-byte receive buffer (IN)\r11Double 64-byte receive buffer, selected by bUH_R_TOG:\nWhen bUH_R_TOG = 0, select the first 64-byte buffer;\nwhen bUH_R_TOG = 1, select the last 64-byte buffer\r\rUSB Host receive buffer start address (UH_RX_DMA): \r\rBitName Access Description Reset value\r\r[7:0]UH_TX_DMA_HRWUSB host send buffer start address high byte, only the lower 5 bits are valid, the upper 3 bits are fixed to 0xxh\r[7:0]UH_TX_DMA_LRWUSB host send buffer start address low byte, only the upper 7 bits are valid, the lowest bit is fixed to 0, only supports even addressxxh\r\rUSB Host transmit start address (UH_TX_DMA): \r\rBitName Access Description Reset value\r\r[7:0]UH_TX_DMA_HRWUSB host send buffer start address high byte, only the lower 5 bits are valid, the upper 3 bits are fixed to 0xxh\r[7:0]UH_TX_DMA_LRWUSB host send buffer start address low byte, only the upper 7 bits are valid, the lowest bit is fixed to 0, only supports even addressxxh\r\r"});index.add({'id':16,'href':'/docs/','title':"Docs",'content':""});})();